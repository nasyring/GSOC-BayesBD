##########################################################################################
#  Author: Nicholas Syring
#  Title: BayesBD
#  Contact: nasyring@ncsu.edu; GitHub
##########################################################################################  	

# Requirements:
#               1. The libraries below.
#               2. A c++ compiler.
#               3. RTools.
#               4. R 3.2+ recommended.


# Directions:
#		1.  Make sure you meet the requirements above.
#		2.  Load the libraries below.
#		3.  Load the functions into your R session: BayesBD.binary, unislice2,
#		    unisliceL, eigenfun, and BayesBDbinary.
#		4.  Run the examples at the end of the code.  There are three examples
#		    comparing the runtime of R code, c++ within and R loop, and pure c++.



# Required libraries.  

library(BayesBD)
library(Rcpp)
library(RcppArmadillo)
library(inline)

# This is an edited version of BayesBD.binary, a function appearing in the BayesBD
# library.  This function produces posterior samples for data from binary images.  

BayesBD.binary = function (obs, ini.mean = 0.4, n.run = 5000, n.burn = 1000, 
    J = 10, output.all = FALSE) 
{
    mu.fun <- function(theta) theta * 0 + ini.mean
    mu = c(mu.fun(obs$theta.obs))
    L = 2 * J + 1
    alpha.tau = 500
    beta.tau = 1
    alpha.lambda = 2
    beta.lambda = 1
    obs$demean = obs$r.obs - mu
    obs$idxOne = which(obs$intensity == 1)
    tmp.mat = sapply(1:L, function(k) eigen.fun(k)(c(obs$theta.obs)))
    an.smp = matrix(NA, L, n.run)
    pi.smp = matrix(NA, 2, n.run)
    tau.smp = rep(NA, n.run)
    lambda.smp = rep(NA, n.run)
    an.ini = rep(0, L)
    pi.in.ini = sum((obs$r.obs < mu) * obs$intensity)/sum(obs$r.obs < 
        mu)
    pi.out.ini = sum((obs$r.obs > mu) * obs$intensity)/sum(obs$r.obs > 
        mu)
    tau.ini = 500
    lambda.ini = 1
    cn.ini = sapply(0:J, function(ith) 2 * pi * exp(-2 * lambda.ini) * 
        besselI(2 * lambda.ini, ith))
    eigen.cn.ini = rep(cn.ini, each = 2)[-1]
    alpha.ini = log(pi.in.ini * (1 - pi.out.ini)/(pi.out.ini * 
        (1 - pi.in.ini)))
    beta.ini = log((1 - pi.in.ini)/(1 - pi.out.ini))
    diff.ini = obs$demean - c(tmp.mat %*% an.ini)
    tmp = (diff.ini < 0)
    n.in <- sum(tmp)
    n.in.one <- sum(tmp[obs$idxOne])
    logL.an.k <- function(k, an, alpha, beta, eigen.cn, tau, 
        diff, tmp.mat) {
        eigen.cn.k = eigen.cn[k]
        an.k = an[k]
        tmp.mat.k = c(tmp.mat[, k])
        ret = function(an.k.candidate) {
            diff.new = diff - (an.k.candidate - an.k) * tmp.mat.k
            tmp = (diff.new <= 0)
            n.in <- sum(tmp)
            n.in.one <- sum(tmp[obs$idxOne])
            ret2 = n.in.one * alpha + n.in * beta - an.k.candidate^2/eigen.cn.k * 
                tau/2
            attr(ret2, "diff") <- diff.new
            attr(ret2, "n.in") <- n.in
            attr(ret2, "n.in.one") <- n.in.one
            return(ret2)
        }
        return(ret)
    }
    logL.lambda = function(tau, an) {
        ret = function(lambda) {
            cn = sapply(0:J, function(ith) 2 * pi * exp(-2 * 
                lambda) * besselI(2 * lambda, ith))
            eigen.cn = rep(cn, each = 2)[-1]
            ret2 = -1/2 * (sum(log(eigen.cn)) + tau * sum(an^2/eigen.cn)) + 
                (alpha.lambda - 1) * log(lambda) - beta.lambda * 
                lambda
            return(ret2)
        }
        return(ret)
    }
    start <- proc.time()
    for (ith in 1:n.run) {
        for (k in 1:L) {
            f.tmp = logL.an.k(k, an.ini, alpha.ini, beta.ini, 
                eigen.cn.ini, tau.ini, diff.ini, tmp.mat)
            tmp2delete <- uni.slice(an.ini[k], g = f.tmp, gx0 = n.in.one * 
                alpha.ini + n.in * beta.ini - an.ini[k]^2/eigen.cn.ini[k] * 
                tau.ini/2)
            tmp2delete.2 = attr(tmp2delete, "log.density")
            diff.ini = attr(tmp2delete.2, "diff")
            n.in = attr(tmp2delete.2, "n.in")
            n.in.one = attr(tmp2delete.2, "n.in.one")
            an.ini[k] <- tmp2delete
        }
        a.star = lambda.ini + L/2
        b.star = beta.tau + sum(an.ini^2/eigen.cn.ini)/2
        tau.ini = rgamma(1, shape = a.star, rate = b.star)
        r.mat = c(tmp.mat %*% an.ini + mu)
        tmp <- (obs$r.obs <= r.mat)
        n.in <- sum(tmp)
        n.in.one <- sum(tmp * obs$intensity)
        n.out = length(r.mat) - n.in
        n.out.one = sum(obs$intensity) - n.in.one
        x1 = rbeta(1, n.in.one, n.in - n.in.one)
        x2 = rbeta(1, n.out.one, n.out - n.out.one)
        pi.in.ini = max(x1, x2)
        pi.out.ini = min(x1, x2)
        alpha.ini = log(pi.in.ini * (1 - pi.out.ini)/(pi.out.ini * 
            (1 - pi.in.ini)))
        beta.ini = log((1 - pi.in.ini)/(1 - pi.out.ini))
        lambda.ini = uni.slice(lambda.ini, g = logL.lambda(tau = tau.ini, 
            an = an.ini), lower = 0, upper = 500)
	  cn.ini = sapply(0:J, function(ith) 2 * pi * exp(-2 * lambda.ini) * 
           besselI(2 * lambda.ini, ith))
        eigen.cn.ini = rep(cn.ini, each = 2)[-1]
        an.smp[, ith] = an.ini
        pi.smp[, ith] = c(pi.in.ini, pi.out.ini)
        lambda.smp[ith] = lambda.ini
        tau.smp[ith] = tau.ini
        if (ith%%floor(n.run/100) == 1) {
            duration = proc.time() - start
            cat(ith, "th iteration:", "ETA:", duration[3]/ith * 
                (n.run - ith), "\n")
        }
    }
    Total.Time = proc.time() - start
    an.MC = apply(an.smp[, n.burn:n.run], 1, mean)
    gamma.MC <- function(theta.arg) {
        c(sapply(1:L, function(k) eigen.fun(k)(theta.arg)) %*% 
            an.MC + mu.fun(theta.arg))
    }
    result = list(gamma.hat = gamma.MC)
    if (output.all) {
        result = list(an.smp = an.smp, pi.smp = pi.smp, tau.smp = tau.smp, 
            lambda.smp = lambda.smp, gamma.hat = gamma.MC)
    }
    return(result)
}


# This is a c++ function which can be used with the Rcpp package to produce posterior
# samples of the eigenfunction coefficients; see ... in Li and Ghosal 2015 for 
# details.  This function is used by another c++ function, BayesBDbinary, below to loop
# the posterior sampling process.

cppFunction(depends = "RcppArmadillo",'Rcpp::List unislice2(arma::colvec x0,arma::colvec diff,arma::colvec tmpmatk,arma::colvec ank,arma::colvec intensity,arma::colvec g2,arma::colvec g4,arma::colvec g5,arma::colvec g6,arma::colvec gx0){
RNGScope scope;
double w = 1.0;
int s = diff.n_rows; 
arma::colvec m = arma::colvec(1);m.fill(10000.0);
double d_m = 10000.0;
arma::colvec lower = arma::colvec(1); lower.fill(-10000.0);
arma::colvec upper = arma::colvec(1); upper.fill(10000.0);
NumericVector rexpval = rexp(1);
arma::colvec logy = arma::colvec(1); logy(0) = gx0(0) - rexpval(0);
arma::colvec x1 = arma::colvec(1); x1.fill(0.0);
arma::colvec gx1 = arma::colvec(1); gx1.fill(0.0);
arma::colvec gxF = arma::colvec(1); gxF.fill(0.0);
arma::colvec u = arma::colvec(1); u = runif(1, 0, w);
arma::colvec L = arma::colvec(1); L = x0 - u;
arma::colvec R = arma::colvec(1); R = x0 + (w - u);
arma::colvec L2 = arma::colvec(1); L2(0)=L(0);
arma::colvec R2 = arma::colvec(1); R2(0)=R(0);
arma::colvec J = arma::colvec(1); J.fill(0.0);
arma::colvec K = arma::colvec(1); K.fill(0.0);
Rcpp::LogicalVector LL = Rcpp::LogicalVector( Rcpp::Dimension(1));
Rcpp::LogicalVector RR = Rcpp::LogicalVector( Rcpp::Dimension(1));
arma::colvec ggL = arma::colvec(1); ggL.fill(0.0);
arma::colvec ggR = arma::colvec(1); ggR.fill(0.0);
Rcpp::LogicalVector gg1 = Rcpp::LogicalVector( Rcpp::Dimension(1));
Rcpp::LogicalVector gxy = Rcpp::LogicalVector( Rcpp::Dimension(1));
Rcpp::LogicalVector x10 = Rcpp::LogicalVector( Rcpp::Dimension(1));
arma::colvec diffnew = arma::colvec(s);diffnew.fill(0.0);
arma::colvec Lv = arma::colvec(s);Lv.fill(L(0));
arma::colvec Rv = arma::colvec(s);Rv.fill(R(0));
arma::colvec xv = arma::colvec(s);xv.fill(0.0);
arma::colvec ankv = arma::colvec(s);ankv.fill(ank(0));
arma::colvec count = arma::colvec(1); count.fill(0.0);
bool res = TRUE;
bool resL = FALSE;
bool resR = FALSE;
bool resg = FALSE;
bool res1 = FALSE;
double dL = 0.0;
double dR = 0.0;
int g1 = 0;
int g3 = 0;
	


        J = floor(runif(1, 0.0, d_m));
        K = (m - 1) - J;
		count = 0.0;
while( res ){
            count = count+1;
		res = count(0) < J(0);
		Lv.fill(L(0));
		diffnew = diff - ((Lv - ankv) % tmpmatk);
		g1 = 0; g3 = 0;
		for(int i=0; i<s;i++){
			if(diffnew(i)<=0){
				g3 = g3+1;
				if(intensity(i)==1){
					g1 = g1+1;
				}
			}
		}
		 resL = (L(0)<=lower(0));
         if (resL){ 
			L2(0) = L(0);
			res= FALSE;}
		ggL = g1*g2+g3*g4-((pow(L,2))/g5)*g6;
       	 resg = (ggL(0) <= logy(0));
           if (resg){ 
			L2(0) = L(0);
			res=FALSE;}
            L = L - w;
     }
	resL = FALSE;
	resg = FALSE;
		count = 0.0;
		res = TRUE;
       while( res ){
            count=count+1;
		res = count(0) < K(0);
		Rv.fill(R(0));
		diffnew = diff - ((Rv - ankv) % tmpmatk);
		g1 = 0; g3 = 0;
		for(int i=0; i<s;i++){
			if(diffnew(i)<=0){
				g3 = g3+1;
				if(intensity(i)==1){
					g1 = g1+1;
				}
			}
		}
		 resL = (R(0)>=upper(0));
            if (resL){ 
               R2(0)=R(0);
			res = FALSE;}
		ggR = g1*g2+g3*g4-((pow(R,2))/g5)*g6;
		 resg = (ggR(0) <= logy(0));
            if (resg){ 
                R2(0)=R(0);
			res = FALSE;}
            R = R + w;
          }
	resL = (L2(0)<lower(0));
    if (resL) {
        L2(0) = lower(0);
    }
	resR = (R2(0)>upper(0));
    if (resR) {
        R2(0) = upper(0);
    }
	count = 0.0;
	res = TRUE;
    while(res) {
		count=count+1;
	res = count(0) < 1000.0 ;
	dL = L2(0);
	dR = R2(0);
        x1 = runif(1, dL, dR);
		xv.fill(x1(0));
		diffnew = diff - ((xv - ankv) % tmpmatk);
	     g1 =0; g3=0;
              for(int i=0; i<s;i++){
			if(diffnew(i)<=0){
				g3 = g3+1;
				if(intensity(i)==1){
					g1 = g1+1;
				}
			}
		}
        gx1 = g1*g2+g3*g4-((pow(x1,2))/g5)*g6;
	  resg = (gx1(0) >= logy(0));
        if (resg){ 
            gxF(0)=gx1(0);
		res = FALSE;
			}
		res1 = (x1(0) > x0(0));
        if (res1) {
            R2(0) = x1(0);
        }
        else {
            L2(0) = x1(0);
        }
    }  
  return Rcpp::List::create(Rcpp::Named("x1") = x1,Rcpp::Named("logdensity") = gxF,Rcpp::Named("diffnew") = diffnew,Rcpp::Named("nin") = g3,Rcpp::Named("ninone") =g1,Rcpp::Named("dL") =dL,Rcpp::Named("dR") =dR);
}')

# This is a c++ function which can be used with the Rcpp package to produce posterior
# samples of the ... parameter; see ... in Li and Ghosal 2015 for 
# details.  This function is used by another c++ function, BayesBDbinary, below to loop
# the posterior sampling process.

cppFunction('Rcpp::List unisliceL(SEXP x0, SEXP gx0, int i_J, SEXP tauini, SEXP anini, SEXP alphalambda, SEXP betalambda, int lambdaini){
RNGScope scope;
Rcpp::Function eigenfun("eigenfun");
Rcpp::Function besselI("besselI");
double w = 1.0;
Rcpp::NumericVector m = Rcpp::NumericVector( Rcpp::Dimension(1));
 m[0] = 100.0; 
double d_m = 100.0;
Rcpp::NumericVector lower = Rcpp::NumericVector( Rcpp::Dimension(1)); lower[0] = 0.0;
Rcpp::NumericVector upper = Rcpp::NumericVector( Rcpp::Dimension(1)); upper[0] = 500.0;
   Rcpp::NumericVector logy = Rcpp::NumericVector( Rcpp::Dimension(1)); logy = Rcpp::as<NumericVector>(gx0) - rexp(1);
   Rcpp::NumericVector u = Rcpp::NumericVector( Rcpp::Dimension(1)); u = runif(1, 0, w);
    Rcpp::NumericVector L = Rcpp::NumericVector( Rcpp::Dimension(1)); L = lambdaini - u;
    Rcpp::NumericVector R = Rcpp::NumericVector( Rcpp::Dimension(1)); R = lambdaini + (w - u);
    Rcpp::NumericVector L2 = Rcpp::NumericVector( Rcpp::Dimension(1)); L2=L;
    Rcpp::NumericVector R2 = Rcpp::NumericVector( Rcpp::Dimension(1)); R2=R;
	Rcpp::NumericVector J = Rcpp::NumericVector( Rcpp::Dimension(1)); J = 0.0;
	Rcpp::NumericVector K = Rcpp::NumericVector( Rcpp::Dimension(1)); K = 0.0;
Rcpp::LogicalVector LL = Rcpp::LogicalVector( Rcpp::Dimension(1));
Rcpp::LogicalVector RR = Rcpp::LogicalVector( Rcpp::Dimension(1));
Rcpp::NumericVector ggL = Rcpp::NumericVector( Rcpp::Dimension(1)); ggL=0.0;
Rcpp::NumericVector ggR = Rcpp::NumericVector( Rcpp::Dimension(1)); ggR=0.0;
Rcpp::LogicalVector gg1 = Rcpp::LogicalVector( Rcpp::Dimension(1));
Rcpp::LogicalVector gxy = Rcpp::LogicalVector( Rcpp::Dimension(1));
Rcpp::NumericVector x1 = Rcpp::NumericVector( Rcpp::Dimension(1));
Rcpp::NumericVector gx1 = Rcpp::NumericVector( Rcpp::Dimension(1));
Rcpp::NumericVector gxF = Rcpp::NumericVector( Rcpp::Dimension(1));
Rcpp::LogicalVector x10 = Rcpp::LogicalVector( Rcpp::Dimension(1));
Rcpp::NumericVector count = Rcpp::NumericVector( Rcpp::Dimension(1)); count=0.0;
Rcpp::NumericVector interim = Rcpp::NumericVector( Rcpp::Dimension(1));interim[0] = 0.0;
Rcpp::NumericVector cnini = Rcpp::NumericVector( Rcpp::Dimension(i_J+1));
Rcpp::NumericVector eigencnini = Rcpp::NumericVector( Rcpp::Dimension(2*i_J+1));
Rcpp::NumericVector calc1 = Rcpp::NumericVector( Rcpp::Dimension(1));calc1[0] = 0.0;
bool res = TRUE;
NumericVector v_anini = Rcpp::as<NumericVector>(anini);
NumericVector v_x0 = Rcpp::as<NumericVector>(x0);
bool resL = FALSE;
bool resR = FALSE;
bool resg = FALSE;
bool res1 = FALSE;


	
        J = floor(runif(1, 0.0, d_m));
        K = (m - 1) - J;
		count = 0.0;
while( res ){
		interim[0]=0.0;
            count = count+1;
		res = is_true( all( count < J ) );
		calc1 = 2*M_PI*exp(-2*L);
		for(int i=0; i<(i_J+1); i++){
				cnini[i] = calc1[0]*Rcpp::as<double>(besselI(pmax(2*L,0),i));
			}
			eigencnini[0] = cnini[0];
			for(int i=1; i<(i_J+1); i++){
				eigencnini[2*i-1] = cnini[i];
				eigencnini[2*i] = cnini[i];
			}
			for(int i=0; i<(2*i_J+1);i++){
				interim[0] = interim[0] + (v_anini[i])*(v_anini[i])/eigencnini[i];
			}
			ggL = -1/2 * (sum(log(eigencnini)) + Rcpp::as<NumericVector>(tauini) * interim) + (Rcpp::as<NumericVector>(alphalambda) - 1) * log(L) - Rcpp::as<NumericVector>(betalambda) * L;
		 resL = (L[0]<=lower[0]);
            if (resL){ 
			L2 = L;
			res= FALSE;}
		 resg = (ggL[0] <= logy[0]);
            if (resg){ 
			L2 = L;
			res=FALSE;}
            L = L - w;
            }
		count = 0.0;
		res = TRUE;
       while( res ){
		interim[0]=0.0;
            count = count+1;
		res = is_true( all( count < K ) );
		calc1 = 2*M_PI*exp(-2*R);
		for(int i=0; i<(i_J+1); i++){
				cnini[i] = calc1[0]*Rcpp::as<double>(besselI(pmax(2*R,0),i));
			}
			eigencnini[0] = cnini[0];
			for(int i=1; i<(i_J+1); i++){
				eigencnini[2*i-1] = cnini[i];
				eigencnini[2*i] = cnini[i];
			}
			for(int i=0; i<(2*i_J+1);i++){
				interim[0] = interim[0] + (v_anini[i])*(v_anini[i])/eigencnini[i];
			}
			ggR = -1/2 * (sum(log(eigencnini)) + Rcpp::as<NumericVector>(tauini) * interim) + (Rcpp::as<NumericVector>(alphalambda) - 1) * log(R) - Rcpp::as<NumericVector>(betalambda) * R;
		 resR = (R[0]<=lower[0]);
            if (resR){ 
			R2 = R;
			res= FALSE;}
		 resg = (ggR[0] <= logy[0]);
            if (resg){ 
			R2 = R;
			res=FALSE;}
            R = R + w;
            }
		
	resL = (L2[0]<lower[0]);
    if (resL) {
        L2 = lower;
    }
	resR = (R2[0]>upper[0]);
    if (resR) {
        R2 = upper;
    }
	count = 0.0;
	res = TRUE;
    while(res) {
		interim[0]=0.0;
		count=count+1;
		res = is_true( all( count < 100 ) );
      	  x1 = runif(1, L2[0], R2[0]);
			calc1 = 2*M_PI*exp(-2*x1);
			for(int i=0; i<(i_J+1); i++){
				cnini[i] = calc1[0]*Rcpp::as<double>(besselI(pmax(2*R,0),i));
			}
			eigencnini[0] = cnini[0];
			for(int i=1; i<(i_J+1); i++){
				eigencnini[2*i-1] = cnini[i];
				eigencnini[2*i] = cnini[i];
			}
			for(int i=0; i<(2*i_J+1);i++){
				interim[0] = interim[0] + (v_anini[i])*(v_anini[i])/eigencnini[i];
			}
			gx1 = -1/2 * (sum(log(eigencnini)) + Rcpp::as<NumericVector>(tauini) * interim) + (Rcpp::as<NumericVector>(alphalambda) - 1) * log(x1) - Rcpp::as<NumericVector>(betalambda) * x1;
	  resg = (gx1[0] >= logy[0]);
        if (resg){ 
            gxF=gx1;
		res = FALSE;
			}
		res1 = (x1[0] > v_x0[0]);
        if (res1) {
            R2 = x1;
        }
        else {
            L2 = x1;
        }
    }  
 	return Rcpp::List::create(Rcpp::Named("x1") = x1);


}')


# This c++ function computes the nth eigenfunction of the SEP kernel.  It is used by
# BayesBDbinary below.


cppFunction('double eigenfun(int n, double x) { 
	int k1 = n%2;
    	double k2 = (n - k1)/2;
	double ret = 0;
   	if (n == 1) {
       		 ret = 1/sqrt(2 * M_PI) + 0 * x;
    	}
    	if (n > 1) {
        	if (k1 == 0) {
            		 ret = 1/sqrt(M_PI) * cos(k2 * x);
        	}
       		if (k1 == 1) {
            		 ret = 1/sqrt(M_PI) * sin(k2 * x);
       		}
    }
    return ret;
}')

# This c++ function is a translation to c++ of the BayesBD.binary R function above.  It
# produces posterior samples of the boundary of a binary image.  The output is a set of
# boundary values at 200 points, to be plotted on the image. 

cppFunction(depends = "RcppArmadillo",'Rcpp::List BayesBDbinary(SEXP obs, SEXP inimean, SEXP nrun, SEXP nburn, SEXP J) { 

// Including additional user-defined Rcpp functions
RNGScope scp;
Rcpp::Function eigenfun("eigenfun");
Rcpp::Function besselI("besselI");
Rcpp::Function unislice2("unislice2");
Rcpp::Function unisliceL("unisliceL");

// Extracting the inputs
Rcpp::List 		      	obsL(obs);
arma::mat thetaobs 	 	= Rcpp::as<arma::mat>(obsL["theta.obs"]);
arma::colvec demean 	 	= Rcpp::as<arma::colvec>(obsL["r.obs"]);
arma::colvec intensityobs     = Rcpp::as<arma::colvec>(obsL["intensity"]);
int i_nrun 				= Rcpp::as<int>(nrun);
int i_nburn				= Rcpp::as<int>(nburn);
int i_J				= Rcpp::as<int>(J);
double d_inimean 			= Rcpp::as<double>(inimean);

// Declaring variables 
Rcpp::List temp2del;
Rcpp::List lambdalist;

int s					= thetaobs.size();
int L                  		= 2*i_J+1;
int betatau           		= 1;
int alphalambda      		= 2;
int betalambda       		= 1;
int nin = 0;
int ninone = 0;
int nout = 0;
int noutone = 0;

arma::colvec tmpmatk		= arma::colvec(s); tmpmatk.fill(0.0);
arma::colvec mu			= arma::colvec(s); mu.fill(d_inimean);
arma::colvec v_demean         = demean - mu;
arma::colvec diffini 		= v_demean; 
arma::colvec eigencnk   	= arma::colvec(1); eigencnk.fill(0.0);
arma::colvec ank   	      = arma::colvec(1); ank.fill(0.0); 
arma::colvec astar   	      = arma::colvec(1); astar(0)=0.0;
arma::colvec bstar   	      = arma::colvec(1); bstar(0)=0.0;
arma::colvec tauinirg   	= arma::colvec(1); tauinirg(0)=500.0;
arma::colvec x1 			= arma::colvec(1); x1.fill(0.0); 
arma::colvec x2 			= arma::colvec(1); x2.fill(0.0);
arma::colvec piin1 		= arma::colvec(1); piin1.fill(0.0);
arma::colvec piin2 		= arma::colvec(1); piin2.fill(0.0);
arma::colvec piout1 		= arma::colvec(1); piout1.fill(0.0);
arma::colvec piout2 		= arma::colvec(1); piout2.fill(0.0);
arma::colvec piinini 		= arma::colvec(1); piinini.fill(0.0);
arma::colvec pioutini 		= arma::colvec(1); pioutini.fill(0.0);
arma::colvec calc1 		= arma::colvec(1); calc1.fill(0.0);
arma::colvec alphaini 		= arma::colvec(1); alphaini.fill(0.0);
arma::colvec betaini 		= arma::colvec(1); betaini.fill(0.0);
arma::colvec lambdaini 		= arma::colvec(1); lambdaini(0)=1.0;
arma::colvec anini 		= arma::colvec(L); anini.fill(0.0);
arma::colvec cnini            = arma::colvec(i_J+1); cnini.fill(0.0);
arma::colvec eigencnini       = arma::colvec(L); eigencnini.fill(0.0);
arma::colvec tmp2del2         = arma::colvec(1); tmp2del2.fill(0.0);
arma::colvec interim          = arma::colvec(1); interim.fill(0.0);
arma::colvec rmat             = arma::colvec(s); rmat.fill(0.0);
arma::colvec tmpp             = arma::colvec(s); tmpp.fill(0.0);
arma::colvec tmp              = arma::colvec(s); tmp.fill(0.0);
arma::colvec gx0              = arma::colvec(1); gx0.fill(0.0);
arma::colvec ansum		= arma::colvec(L); ansum.fill(0.0);
arma::mat tmpmat              = arma::mat(s,L); tmpmat.fill(0.0);

// Filling tmpmat with values for each of L eigenfunctions for each of s observations
for (int i=0; i<s; i++) {
	for(int j = 0; j<L;j++){
            tmpmat(i,j) = Rcpp::as<double>(eigenfun(j+1,thetaobs[i]));
	}
}


for(int i = 0; i<s; i++){
	if(demean(i) < mu(i)){
		if(intensityobs(i) == 1.0){
			piin1(0) = piin1(0) + 1.0;
		}
	}
}

for(int i = 0; i<s; i++){
	if(demean(i) < mu(i)){
		piin2(0) = piin2(0) + 1.0;
	}
}

for(int i = 0; i<s; i++){
	if(demean(i) >= mu(i)){
		if(intensityobs(i) == 1.0){
			piout1(0) = piout1(0) + 1.0;
		}
	}
}

for(int i = 0; i<s; i++){
	if(demean(i) >= mu(i)){
		piout2(0) = piout2(0) + 1.0;
	}
}

piinini = piin1 / piin2;
pioutini = piout1 / piout2;


calc1 = 2*M_PI*exp(-2*lambdaini);
for(int i=0; i<(i_J+1); i++){
	cnini(i) = calc1(0)*Rcpp::as<double>(besselI(max(2*lambdaini,0.0),i));
}

eigencnini(0) = cnini(0);
for(int i=1; i<(i_J+1); i++){
	eigencnini(2*i-1) = cnini(i);
	eigencnini(2*i) = cnini(i);
} 
alphaini = log(piinini*(1-pioutini)/(pioutini*(1-piinini)));
betaini = log((1 - piinini)/(1 - pioutini));
for(int i = 0; i<s; i++){
	if(diffini(i)<0){
		tmp(i) = 1;
	}
}

nin = sum(tmp);
for(int i=0; i<s; i++){
	if(intensityobs(i)==1){
	ninone = ninone + tmp(i);
	}
}

Rcpp::NumericVector thetaplot = Rcpp::NumericVector( Rcpp::Dimension(200));
for(int k = 0; k<200; k++){
 thetaplot[k] = 2.0*M_PI*(k/200.0); 
}
Rcpp::NumericVector estfunc = Rcpp::NumericVector( Rcpp::Dimension(1));
Rcpp::NumericVector esttheta = Rcpp::NumericVector( Rcpp::Dimension(200));

//main loop
for(int i=0; i<(i_nrun+i_nburn); i++){
for(int k=0; k<L; k++){
		eigencnk(0) = eigencnini(k);
		ank(0) = anini(k);
		tmpmatk = tmpmat.col(k);
		gx0 = ninone*alphaini+nin*betaini-(((pow(ank,2))/eigencnk)*tauinirg/2);
		temp2del = unislice2(ank,diffini,tmpmatk,ank,intensityobs,alphaini,betaini,eigencnk,tauinirg/2, ninone*alphaini+nin*betaini-(((pow(ank,2))/eigencnk)*tauinirg/2));
		tmp2del2 = Rcpp::as<arma::colvec>(temp2del["logdensity"]);
		anini(k) = Rcpp::as<double>(temp2del["x1"]);
		ninone = Rcpp::as<int>(temp2del["ninone"]);
		nin = Rcpp::as<int>(temp2del["nin"]);
		diffini = Rcpp::as<arma::colvec>(temp2del["diffnew"]);
	}

astar = lambdaini + L/2;
interim = anini.t()*(anini / eigencnini);
bstar = betatau + interim/2;
tauinirg = rgamma(1,astar(0),bstar(0));
rmat.fill(0);
rmat = tmpmat*anini + mu;
for(int j = 0; j< s; j++){
	if(demean(j)<=rmat(j)){tmpp(j)=1.0;}
	else{tmpp(j)=0.0;}
}
nin = sum(tmpp);
ninone = sum(intensityobs%tmpp);
nout = s - nin;
noutone = sum(intensityobs) - ninone;

x1 = rbeta(1, ninone, nin - ninone);
x2 = rbeta(1, noutone, nout - noutone);

piinini = max(x1, x2);
pioutini = min(x1, x2);

alphaini = log(piinini * (1 - pioutini)/(pioutini *(1 - piinini)));
betaini = log((1 - piinini)/(1 - pioutini));

gx0 = -1/2 * (sum(log(eigencnini)) + tauinirg * interim) + (alphalambda - 1) * log(lambdaini) - betalambda * lambdaini;

lambdalist = unisliceL(lambdaini, gx0, i_J, tauinirg, anini,  alphalambda,  betalambda, lambdaini);
lambdaini = Rcpp::as<NumericVector>(lambdalist["x1"]);

ansum = ansum + anini;

}

ansum = ansum/i_nrun;
for(int k = 0; k<200; k++){
		estfunc[0]=0.0;
  		for(int j = 0; j<L; j++){
			estfunc[0] = estfunc[0] + Rcpp::as<double>(eigenfun(j+1,thetaplot[k]))*ansum(j)+(d_inimean/L);
		}
		esttheta[k] =estfunc[0]+esttheta[k];
}

//return Rcpp::List::create(Rcpp::Named("anini") = anini, Rcpp::Named("eigencnk") = eigencnk, Rcpp::Named("tmpmatk") = tmpmatk, Rcpp::Named("nin") = nin, Rcpp::Named("ninone") =ninone, Rcpp::Named("diffini") =  diffini,Rcpp::Named("gx0") =  gx0,Rcpp::Named("ank") =  ank,Rcpp::Named("eigencnini") =  eigencnini, Rcpp::Named("cnini") =  cnini );
return Rcpp::List::create(Rcpp::Named("esttheta") = esttheta,Rcpp::Named("thetaplot") = thetaplot);
}')



# Examples: What follows are examples of using R code only, and R loop with c++ sampling,
# and c++ only to produce boundary estimates for binary images.  We set the seed before
# each example to use the same data, and we compute the runtime for comparison. 



# Example 1: R code only.  This uses the code from
set.seed(12345)
gamma.fun = ellipse(a = 0.35, b = 0.25)
obs = par2obs(m = 100, pi.in = 0.5, pi.out = 0.2, design = 'J', gamma.fun)
rotate <- function(x) t(apply(x, 2, rev))  # rotate closewise by 90 degrees
image(rotate(obs$intensity), axes = FALSE, asp = 1, main = 'observation')
t1 = proc.time()
rbinary = BayesBD.binary(obs, ini.mean = 0.4, n.run = 5000, n.burn = 1000, J = 10, output.all = FALSE) 
t2 = proc.time()
t2-t1
theta.plot = seq(from = 0, to = 2*pi, length.out = 200)
plot.val = rbinary$gamma.hat(theta.plot)
x.plot = plot.val*cos(theta.plot)+.5
y.plot = plot.val*sin(theta.plot)+.5
lines(x.plot, y.plot, lwd=2)



# Example 2: c++ functions unislice2 and unisliceL used for MCMC updating are called # within an R loop
set.seed(12345)
gamma.fun = ellipse(a = 0.35, b = 0.25)
obs = par2obs(m = 100, pi.in = 0.5, pi.out = 0.2, design = 'J', gamma.fun)
rotate <- function(x) t(apply(x, 2, rev))  # rotate closewise by 90 degrees
image(rotate(obs$intensity), axes = FALSE, asp = 1, main = 'observation')
t1 = proc.time()
ini.mean = 0.4
n.run = 5000
n.burn = 1000
J = 10

    mu.fun <- function(theta) theta * 0 + ini.mean
    mu = c(mu.fun(obs$theta.obs))
    L = 2 * J + 1
    alpha.tau = 500
    beta.tau = 1
    alpha.lambda = 2
    beta.lambda = 1
    obs$demean = obs$r.obs - mu
    obs$idxOne = which(obs$intensity == 1)
    tmp.mat = sapply(1:L, function(k) eigen.fun(k)(c(obs$theta.obs)))
    an.smp = matrix(NA, L, n.run)
    pi.smp = matrix(NA, 2, n.run)
    tau.smp = rep(NA, n.run)
    lambda.smp = rep(NA, n.run)
    an.ini = rep(0, L)
    pi.in.ini = sum((obs$r.obs < mu) * obs$intensity)/sum(obs$r.obs < 
        mu)
    pi.out.ini = sum((obs$r.obs > mu) * obs$intensity)/sum(obs$r.obs > 
        mu)
    tau.ini = 500
    lambda.ini = 1
    cn.ini = sapply(0:J, function(ith) 2 * pi * exp(-2 * lambda.ini) * 
        besselI(2 * lambda.ini, ith))
    eigen.cn.ini = rep(cn.ini, each = 2)[-1]
    alpha.ini = log(pi.in.ini * (1 - pi.out.ini)/(pi.out.ini * 
        (1 - pi.in.ini)))
    beta.ini = log((1 - pi.in.ini)/(1 - pi.out.ini))
    diff.ini = obs$demean - c(tmp.mat %*% an.ini)
    tmp = (diff.ini < 0)
    n.in <- sum(tmp)
    n.in.one <- sum(tmp[obs$idxOne])
	diff.ini = as.vector(diff.ini)
    
    for (ith in 1:n.run) {
        for (k in 1:L) {
            tmp2delete = unislice2(an.ini[k],diff.ini,tmp.mat[,k],an.ini[k],as.vector(obs$intensity),alpha.ini,beta.ini,eigen.cn.ini[k],tau.ini/2, n.in.one*alpha.ini+n.in*beta.ini-(((an.ini[k]^2)/eigen.cn.ini[k])*tau.ini/2))
            an.ini[k] = tmp2delete$x1
		diff.ini = tmp2delete$diffnew
		n.in.one = tmp2delete$ninone
		n.in = tmp2delete$nin
        }
        a.star = lambda.ini + L/2
        b.star = beta.tau + sum(an.ini^2/eigen.cn.ini)/2
        tau.ini = rgamma(1, shape = a.star, rate = b.star)
        r.mat = c(tmp.mat %*% an.ini + mu)
        tmp = (obs$r.obs <= r.mat)
        n.in = sum(tmp)
        n.in.one = sum(tmp * obs$intensity)
        n.out = length(r.mat) - n.in
        n.out.one = sum(obs$intensity) - n.in.one
        x1 = rbeta(1, n.in.one, n.in - n.in.one)
        x2 = rbeta(1, n.out.one, n.out - n.out.one)
        pi.in.ini = max(x1, x2)
        pi.out.ini = min(x1, x2)
        alpha.ini = log(pi.in.ini * (1 - pi.out.ini)/(pi.out.ini * 
            (1 - pi.in.ini)))
        beta.ini = log((1 - pi.in.ini)/(1 - pi.out.ini))
	  gx0 = -1/2 * (sum(log(eigen.cn.ini)) + tau.ini * sum((an.ini^2)/eigen.cn.ini)) + (alpha.lambda - 1) * log(lambda.ini) - beta.lambda * lambda.ini
	  lambda.ini = unisliceL(lambda.ini, gx0, J, tau.ini, an.ini,  alpha.lambda,  beta.lambda, lambda.ini)$x1
        cn.ini = sapply(0:J, function(ith) 2 * pi * exp(-2 * lambda.ini) * 
           besselI(2 * lambda.ini, ith))
        eigen.cn.ini = rep(cn.ini, each = 2)[-1]
	  an.smp[, ith] = an.ini
        pi.smp[, ith] = c(pi.in.ini, pi.out.ini)
        lambda.smp[ith] = lambda.ini
        tau.smp[ith] = tau.ini
        }
    an.MC = apply(an.smp[, n.burn:n.run], 1, mean)
    gamma.MC <- function(theta.arg) {
        c(sapply(1:L, function(k) eigen.fun(k)(theta.arg)) %*% 
            an.MC + mu.fun(theta.arg))
    }

t2 = proc.time()
t2-t1
theta.plot = seq(from = 0, to = 2*pi, length.out = 200)
plot.val = gamma.MC(theta.plot)
x.plot = plot.val*cos(theta.plot)+.5
y.plot = plot.val*sin(theta.plot)+.5
lines(x.plot, y.plot, lwd=2)


# Example 3: c++ only.  BayesBD is used to run the entire sampling process within c++.
set.seed(12345)
gamma.fun = ellipse(a = 0.35, b = 0.25)
obs = par2obs(m = 100, pi.in = 0.5, pi.out = 0.2, design = 'J', gamma.fun)
rotate <- function(x) t(apply(x, 2, rev))  # rotate closewise by 90 degrees
image(rotate(obs$intensity), axes = FALSE, asp = 1, main = 'observation')
t1 = proc.time()
cppsamp = BayesBDbinary(obs, .4, 5000, 1000, 10)
t2 = proc.time()
t2-t1
x = cppsamp$esttheta*cos(cppsamp$thetaplot)+.5
y = cppsamp$esttheta*sin(cppsamp$thetaplot) +.5
lines(x,y, lty = 2, lwd = 3)

# Runtime results: on an Intel Core i7-4790K CPU @ 4.00 GHz with 16 GB RAM running RGui 64-bit on Windows 10
#                       user      system    elapsed
#   c++ only            73.40     6.98      80.50 
#   c++ within R loop   139.57    5.69      145.31  
#   Only R              230.86    0.44      233.89 

