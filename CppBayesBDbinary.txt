##########################################################################################
#  Author: Nicholas Syring
#  Title: BayesBD
#  Contact: nasyring@ncsu.edu; GitHub
##########################################################################################  	

# Requirements:
#               1. The libraries below.
#               2. A c++ compiler.
#               3. RTools.
#               4. R 3.2+ recommended.


# Directions:
#		1.  Make sure you meet the requirements above.
#		2.  Load the libraries below.
#		3.  Load the functions into your R session: BayesBD.binary, unislice2,
#		    unisliceL, eigenfun, BayesBDbinary, and triangle2.
#		4.  Run the examples at the end of the code.  There are three examples
#		    comparing the runtime of R code, c++ within and R loop, and pure c++.
#		    There are also 4 examples from the paper using just c++ code.



# Required libraries.  

library(BayesBD)
library(Rcpp)
library(RcppArmadillo)
library(inline)
library(plotrix)

# This is an edited version of BayesBD.binary, a function appearing in the BayesBD
# library.  This function produces posterior samples for data from binary images.  

BayesBD.binary = function (obs, ini.mean = 0.4, n.run = 5000, n.burn = 1000, 
    J = 10, output.all = FALSE) 
{
    mu.fun <- function(theta) theta * 0 + ini.mean
    mu = c(mu.fun(obs$theta.obs))
    L = 2 * J + 1
    alpha.tau = 500
    beta.tau = 1
    alpha.lambda = 2
    beta.lambda = 1
    obs$demean = obs$r.obs - mu
    obs$idxOne = which(obs$intensity == 1)
    tmp.mat = sapply(1:L, function(k) eigen.fun(k)(c(obs$theta.obs)))
    an.smp = matrix(NA, L, n.run)
    pi.smp = matrix(NA, 2, n.run)
    tau.smp = rep(NA, n.run)
    lambda.smp = rep(NA, n.run)
    an.ini = rep(0, L)
    pi.in.ini = sum((obs$r.obs < mu) * obs$intensity)/sum(obs$r.obs < 
        mu)
    pi.out.ini = sum((obs$r.obs > mu) * obs$intensity)/sum(obs$r.obs > 
        mu)
    tau.ini = 500
    lambda.ini = 1
    cn.ini = sapply(0:J, function(ith) 2 * pi * exp(-2 * lambda.ini) * 
        besselI(2 * lambda.ini, ith))
    eigen.cn.ini = rep(cn.ini, each = 2)[-1]
    alpha.ini = log(pi.in.ini * (1 - pi.out.ini)/(pi.out.ini * 
        (1 - pi.in.ini)))
    beta.ini = log((1 - pi.in.ini)/(1 - pi.out.ini))
    diff.ini = obs$demean - c(tmp.mat %*% an.ini)
    tmp = (diff.ini < 0)
    n.in <- sum(tmp)
    n.in.one <- sum(tmp[obs$idxOne])
    logL.an.k <- function(k, an, alpha, beta, eigen.cn, tau, 
        diff, tmp.mat) {
        eigen.cn.k = eigen.cn[k]
        an.k = an[k]
        tmp.mat.k = c(tmp.mat[, k])
        ret = function(an.k.candidate) {
            diff.new = diff - (an.k.candidate - an.k) * tmp.mat.k
            tmp = (diff.new <= 0)
            n.in <- sum(tmp)
            n.in.one <- sum(tmp[obs$idxOne])
            ret2 = n.in.one * alpha + n.in * beta - an.k.candidate^2/eigen.cn.k * 
                tau/2
            attr(ret2, "diff") <- diff.new
            attr(ret2, "n.in") <- n.in
            attr(ret2, "n.in.one") <- n.in.one
            return(ret2)
        }
        return(ret)
    }
    logL.lambda = function(tau, an) {
        ret = function(lambda) {
            cn = sapply(0:J, function(ith) 2 * pi * exp(-2 * 
                lambda) * besselI(2 * lambda, ith))
            eigen.cn = rep(cn, each = 2)[-1]
            ret2 = -1/2 * (sum(log(eigen.cn)) + tau * sum(an^2/eigen.cn)) + 
                (alpha.lambda - 1) * log(lambda) - beta.lambda * 
                lambda
            return(ret2)
        }
        return(ret)
    }
    for (ith in 1:n.run) {
        for (k in 1:L) {
            f.tmp = logL.an.k(k, an.ini, alpha.ini, beta.ini, 
                eigen.cn.ini, tau.ini, diff.ini, tmp.mat)
            tmp2delete <- uni.slice(an.ini[k], g = f.tmp, gx0 = n.in.one * 
                alpha.ini + n.in * beta.ini - an.ini[k]^2/eigen.cn.ini[k] * 
                tau.ini/2, m = 20, lower = -10000, upper = 10000)
            tmp2delete.2 = attr(tmp2delete, "log.density")
            diff.ini = attr(tmp2delete.2, "diff")
            n.in = attr(tmp2delete.2, "n.in")
            n.in.one = attr(tmp2delete.2, "n.in.one")
            an.ini[k] <- tmp2delete
        }
        a.star = lambda.ini + L/2
        b.star = beta.tau + sum(an.ini^2/eigen.cn.ini)/2
        tau.ini = rgamma(1, shape = a.star, rate = b.star)
        r.mat = c(tmp.mat %*% an.ini + mu)
        tmp <- (obs$r.obs <= r.mat)
        n.in <- sum(tmp)
        n.in.one <- sum(tmp * obs$intensity)
        n.out = length(r.mat) - n.in
        n.out.one = sum(obs$intensity) - n.in.one
        x1 = rbeta(1, n.in.one, n.in - n.in.one)
        x2 = rbeta(1, n.out.one, n.out - n.out.one)
        pi.in.ini = max(x1, x2)
        pi.out.ini = min(x1, x2)
        alpha.ini = log(pi.in.ini * (1 - pi.out.ini)/(pi.out.ini * 
            (1 - pi.in.ini)))
        beta.ini = log((1 - pi.in.ini)/(1 - pi.out.ini))
        lambda.ini = uni.slice(lambda.ini, g = logL.lambda(tau = tau.ini, 
            an = an.ini), lower = 0, upper = 500, m = 20)
	  cn.ini = sapply(0:J, function(ith) 2 * pi * exp(-2 * lambda.ini) * 
           besselI(2 * lambda.ini, ith))
        eigen.cn.ini = rep(cn.ini, each = 2)[-1]
        an.smp[, ith] = an.ini
        pi.smp[, ith] = c(pi.in.ini, pi.out.ini)
        lambda.smp[ith] = lambda.ini
        tau.smp[ith] = tau.ini
        }
    an.MC = apply(an.smp[, n.burn:n.run], 1, mean)
    gamma.MC <- function(theta.arg) {
        c(sapply(1:L, function(k) eigen.fun(k)(theta.arg)) %*% 
            an.MC + mu.fun(theta.arg))
    }
    result = list(gamma.hat = gamma.MC)
    if (output.all) {
        result = list(an.smp = an.smp, pi.smp = pi.smp, tau.smp = tau.smp, 
            lambda.smp = lambda.smp, gamma.hat = gamma.MC)
    }
    return(result)
}


# This is a c++ function which can be used with the Rcpp package to produce posterior
# samples of the eigenfunction coefficients; see ... in Li and Ghosal 2015 for 
# details.  This function is used by another c++ function, BayesBDbinary, below to loop
# the posterior sampling process.

cppFunction(depends = "RcppArmadillo",'Rcpp::List unislice2(arma::colvec & x0,arma::colvec & diff,arma::colvec & tmpmatk,arma::colvec & ank,arma::colvec & intensity,arma::colvec & g2,arma::colvec & g4,arma::colvec & g5,arma::colvec & g6,arma::colvec & gx0){
RNGScope scope;
int s = diff.n_rows; 
arma::colvec m = arma::colvec(1);m.fill(10000.0);
NumericVector rexpval = rexp(1);
arma::colvec logy = arma::colvec(1); logy(0) = gx0(0) - rexpval(0);
arma::colvec x1 = arma::colvec(1); x1.fill(0.0);
rexpval = runif(1, 0, 1.0);
arma::colvec LL = arma::colvec(1); LL(0) = x0(0) - rexpval[0];
arma::colvec R = arma::colvec(1); R = LL + 1.0;
arma::colvec g = arma::colvec(1); g.fill(0.0);
arma::colvec diffnew = arma::colvec(s);diffnew.fill(0.0);
arma::colvec Lv = arma::colvec(s);Lv.fill(LL(0));
arma::colvec Rv = arma::colvec(s);Rv.fill(R(0));
arma::colvec xv = arma::colvec(s);xv.fill(0.0);
arma::colvec ankv = arma::colvec(s);ankv.fill(ank(0));
arma::colvec count = arma::colvec(1); count.fill(0.0);
bool res1 = TRUE;
bool res2 = FALSE;
bool res3 = FALSE;
int g1 = 0;
int g3 = 0;
	


		count = 0.0;
while( res1 ){
            count = count+1;
		res1 = count(0) < 100.0;
		res2 = LL(0)<=-10000;
		if(res2){
			LL(0) = LL(0)+1;
			res1 = FALSE;
		}
		else {
		Lv.fill(LL(0));
		diffnew = diff - ((Lv - ankv) % tmpmatk);
		g1 = 0; g3 = 0;
		for(int i=0; i<s;i++){
			if(diffnew(i)<=0){
				g3 = g3+1;
				if(intensity(i)==1){
					g1 = g1+1;
				}
			}
		}
		g = g1*g2+g3*g4-((pow(LL,2))/g5)*g6;
       	 res3 = g(0) <= logy(0);
		}
           if (res3){ 
			LL(0) = LL(0) + 1.0;
			res1=FALSE;}
            LL(0) = LL(0) - 1.0;
    }

	res2 = FALSE;
	res3 = FALSE;
		count = 0.0;
		res1 = TRUE;
       while( res1 ){
            count=count+1.0;
		res1 = count(0) < 100.0;
		res2 = R(0)>=10000.0;
		if(res2){
			R(0) = R(0) - 1.0;
			res1 = FALSE;
		}
		else {
		Rv.fill(R(0));
		diffnew = diff - ((Rv - ankv) % tmpmatk);
		g1 = 0; g3 = 0;
		for(int i=0; i<s;i++){
			if(diffnew(i)<=0){
				g3 = g3+1;
				if(intensity(i)==1){
					g1 = g1+1;
				}
			}
		}
		 g = g1*g2+g3*g4-((pow(R,2))/g5)*g6;
		 res3 = g(0) <= logy(0);
      	}      
	if (res3){ 
                R(0)=R(0)-1.0;
			res1 = FALSE;}
            R(0) = R(0) + 1.0;
          }
	res1 = (LL(0)<-10000.0);
    if (res1) {
        LL(0) = -10000.0;
    }
	res1 = (R(0)>10000.0);
    if (res1) {
        R(0) = 10000.0;
    }
	count = 0.0;
	res1 = TRUE;
	res2 = FALSE;
	res3 = FALSE;
    while(res1) {
		count=count+1;
	res1 = count(0) < 200.0 ;
		if(res2){
		res1 = FALSE;
		}
	else{
        x1 = runif(1, LL(0), R(0));
		xv.fill(x1(0));
		diffnew = diff - ((xv - ankv) % tmpmatk);
	     g1 =0; g3=0;
              for(int i=0; i<s;i++){
			if(diffnew(i)<=0){
				g3 = g3+1;
				if(intensity(i)==1){
					g1 = g1+1;
				}
			}
		}
        g = g1*g2+g3*g4-((pow(x1,2))/g5)*g6;
	   res3 = (x1(0) > x0(0));
	}
 	res2 = (g(0) >= logy(0));
        if (res3) {
            R(0) = x1(0);
        }
        else {
            LL(0) = x1(0);
        }
    }  
  return Rcpp::List::create(Rcpp::Named("x1") = x1,Rcpp::Named("logdensity") = g,Rcpp::Named("diffnew") = diffnew,Rcpp::Named("nin") = g3,Rcpp::Named("ninone") =g1,Rcpp::Named("count") =count);
}')



# This is a c++ function which can be used with the Rcpp package to produce posterior
# samples of the ... parameter; see ... in Li and Ghosal 2015 for 
# details.  This function is used by another c++ function, BayesBDbinary, below to loop
# the posterior sampling process.

cppFunction(depends = "RcppArmadillo",'Rcpp::List unisliceL(arma::colvec & x0, arma::colvec & gx0, int & i_J, arma::colvec & tauini, arma::colvec & anini, int & alphalambda, int & betalambda, arma::colvec & lambdaini){
RNGScope scope;
Rcpp::Function besselI("besselI");
Rcpp::NumericVector rndsmp = Rcpp::NumericVector( Rcpp::Dimension(1)); rndsmp = rexp(1);
arma::colvec logy = arma::colvec(1); logy(0) = gx0(0) - rndsmp[0];
rndsmp = runif(1, 0, 1.0);
arma::colvec L = arma::colvec(1); L(0) = lambdaini(0) - rndsmp[0];
arma::colvec R = arma::colvec(1); R(0) = L(0) + 1.0;
arma::colvec x1 = arma::colvec(1);x1(0)=0.0;
arma::colvec g = arma::colvec(1); g(0)=0.0;
arma::colvec count = arma::colvec(1); count(0)=0.0;
arma::colvec interim = arma::colvec(1);interim(0) = 0.0;
arma::colvec cnini = arma::colvec(i_J+1);
arma::colvec eigencnini = arma::colvec(2*i_J+1);
arma::colvec calc1 = arma::colvec(1);calc1(0) = 0.0;
bool res1 = TRUE;
bool res2 = FALSE;
bool res3 = FALSE;


while( res1 ){
		interim(0)=0.0;
            count = count+1.0;
		res1 =  count(0) < 20.0 ;
	      res2 = L(0)<=0.0;
            if (res2){ 
			L(0) = L(0)+1.0;
			res1= FALSE;}
		else {
			calc1 = 2*M_PI*exp(-2*L);
			for(int i=0; i<(i_J+1); i++){
				cnini(i) = calc1(0)*Rcpp::as<double>(besselI(2*L,i));
			}
			eigencnini(0) = cnini(0);
			for(int i=1; i<(i_J+1); i++){
				eigencnini(2*i-1) = cnini(i);
				eigencnini(2*i) = cnini(i);
			} 
			interim = anini.t()*(anini / eigencnini);
			g = -0.5 * (sum(log(eigencnini)) + tauini * interim) + (alphalambda - 1) * log(L) - betalambda * L;
			res3 = g(0) <= logy(0);
		}
            if (res3){ 
			L(0) = L(0)+1.0;
			res1=FALSE;}
            L(0) = L(0) - 1.0;
           }
		 count = 0.0;
		res1 = TRUE;res2 = FALSE;res3 = FALSE;
       while( res1 ){
		interim(0)=0.0;
            count = count+1.0;
		res1 =  count(0) < 20.0 ;
		res2 = R(0)>=500.0;
            if (res2){ 
			R(0) = R(0)-1.0;
			res1= FALSE;}
		else {
			calc1 = 2*M_PI*exp(-2*R);
			for(int i=0; i<(i_J+1); i++){
				cnini(i) = calc1(0)*Rcpp::as<double>(besselI(2*R,i));
			}
			eigencnini(0) = cnini(0);
			for(int i=1; i<(i_J+1); i++){
				eigencnini(2*i-1) = cnini(i);
				eigencnini(2*i) = cnini(i);
			}
			interim = anini.t()*(anini / eigencnini);
			g = -0.5 * (sum(log(eigencnini)) + tauini * interim) + (alphalambda - 1) * log(R) - betalambda * R;
			res3 = (g(0) <= logy(0));
		}
            if (res3){ 
			R(0) = R(0)-1.0;
			res1=FALSE;}
            R(0) = R(0) + 1.0;
            }
		
	res1 = L(0)<=0.0;
    if (res1) {
        L(0) = 0.0;
    }
	res1 = R(0)>500.0;
    if (res1) {
        R(0) = 500.0;
    }
	count = 0.0;
	res1 = TRUE;res2 = FALSE;res3 = FALSE;
    while(res1) {
		interim(0)=0.0;
		count=count+1;
		res1 =  count(0) < 100.0  ;
       	if (res2){ 
			res1 = FALSE;
			}
		else {
			x1 = runif(1, L(0), R(0));
			calc1 = 2*M_PI*exp(-2*x1);
			for(int i=0; i<(i_J+1); i++){
				cnini(i) = calc1(0)*Rcpp::as<double>(besselI(2*x1,i));
			}
			eigencnini(0) = cnini(0);
			for(int i=1; i<(i_J+1); i++){
				eigencnini(2*i-1) = cnini(i);
				eigencnini(2*i) = cnini(i);
			}
			interim = anini.t()*(anini / eigencnini);
			g = -0.5 * (sum(log(eigencnini)) + tauini * interim) + (alphalambda - 1) * log(x1) - betalambda * x1;
			res3 = (x1(0) > x0(0));
		}
	  	  	res2 = (g(0) >= logy(0));
        if (res3) {
            R(0) = x1(0);
        }
        else {
            L(0) = x1(0);
        }
    }  
 	return Rcpp::List::create(Rcpp::Named("x1") = x1, Rcpp::Named("count") = count);
}')


# This c++ function computes the nth eigenfunction of the SEP kernel.  It is used by
# BayesBDbinary below.


cppFunction('double eigenfun(int & n, double & x) { 
	int k1 = n%2;
    	double k2 = (n - k1)/2;
	double ret = 0;
   	if (n == 1) {
       		 ret = 1/sqrt(2 * M_PI) + 0 * x;
    	}
    	if (n > 1) {
        	if (k1 == 0) {
            		 ret = 1/sqrt(M_PI) * cos(k2 * x);
        	}
       		if (k1 == 1) {
            		 ret = 1/sqrt(M_PI) * sin(k2 * x);
       		}
    }
    return ret;
}')

# This c++ function is a translation to c++ of the BayesBD.binary R function above.  It
# produces posterior samples of the boundary of a binary image.  The output is a set of
# boundary values at 200 points, to be plotted on the image. 

cppFunction(depends = "RcppArmadillo",'Rcpp::List BayesBDbinary(SEXP & obs, SEXP & inimean, SEXP & nrun, SEXP & nburn, SEXP & J, bool Slice) { 

// Including additional user-defined Rcpp functions
RNGScope scp;
Rcpp::Function eigenfun("eigenfun");
Rcpp::Function besselI("besselI");
Rcpp::Function unisliceL("unisliceL");

// Extracting the inputs
Rcpp::List 		      	obsL(obs);
arma::mat thetaobs 	 	= Rcpp::as<arma::mat>(obsL["theta.obs"]);
arma::colvec demean 	 	= Rcpp::as<arma::colvec>(obsL["r.obs"]);
arma::colvec intensityobs     = Rcpp::as<arma::colvec>(obsL["intensity"]);
int i_nrun 				= Rcpp::as<int>(nrun);
int i_nburn				= Rcpp::as<int>(nburn);
int i_J				= Rcpp::as<int>(J);
double d_inimean 			= Rcpp::as<double>(inimean); 


// Declaring variables 
Rcpp::List temp2del;
Rcpp::List lambdalist;

int s					= thetaobs.size();
int L                  		= 2*i_J+1;
int betatau           		= 1;
int alphalambda      		= 2;
int betalambda       		= 1;
int nin = 0;
int ninone = 0;
int nout = 0;
int noutone = 0;

arma::colvec tmpmatk		= arma::colvec(s); tmpmatk.fill(0.0);
arma::colvec mu			= arma::colvec(s); mu.fill(d_inimean);
arma::colvec diffini 		= demean - mu; 
arma::colvec eigencnk   	= arma::colvec(1); eigencnk.fill(0.0);
arma::colvec ank   	      = arma::colvec(1); ank.fill(0.0); 
arma::colvec astar   	      = arma::colvec(1); astar(0)=0.0;
arma::colvec bstar   	      = arma::colvec(1); bstar(0)=0.0;
arma::colvec tauinirg   	= arma::colvec(1); tauinirg(0)=500.0;
arma::colvec x1 			= arma::colvec(1); x1.fill(0.0); 
arma::colvec x2 			= arma::colvec(1); x2.fill(0.0);
arma::colvec piin1 		= arma::colvec(1); piin1.fill(0.0);
arma::colvec piin2 		= arma::colvec(1); piin2.fill(0.0);
arma::colvec piout1 		= arma::colvec(1); piout1.fill(0.0);
arma::colvec piout2 		= arma::colvec(1); piout2.fill(0.0);
arma::colvec piinini 		= arma::colvec(1); piinini.fill(0.0);
arma::colvec pioutini 		= arma::colvec(1); pioutini.fill(0.0);
arma::colvec calc1 		= arma::colvec(1); calc1.fill(0.0);
arma::colvec alphaini 		= arma::colvec(1); alphaini.fill(0.0);
arma::colvec betaini 		= arma::colvec(1); betaini.fill(0.0);
arma::colvec lambdaini 		= arma::colvec(1); lambdaini(0)=1.0;
arma::colvec anini 		= arma::colvec(L); anini.fill(0.0);
arma::colvec cnini            = arma::colvec(i_J+1); cnini.fill(0.0);
arma::colvec eigencnini       = arma::colvec(L); eigencnini.fill(0.0);
arma::colvec tmp2del2         = arma::colvec(1); tmp2del2.fill(0.0);
arma::colvec interim          = arma::colvec(1); interim.fill(0.0);
arma::colvec rmat             = arma::colvec(s); rmat.fill(0.0);
arma::colvec tmpp             = arma::colvec(s); tmpp.fill(0.0);
arma::colvec tmp              = arma::colvec(s); tmp.fill(0.0);
arma::colvec gx0              = arma::colvec(1); gx0.fill(0.0);
arma::colvec ansum		= arma::colvec(L); ansum.fill(0.0);
arma::mat ansmp			= arma::mat(L,i_nrun); ansmp.fill(0.0);
arma::mat tmpmat              = arma::mat(s,L); tmpmat.fill(0.0);

// Variables used for slice and MH sampling
arma::colvec m = arma::colvec(1);m.fill(10000.0);
NumericVector rexpval;
arma::colvec logy = arma::colvec(1); 
arma::colvec xx1 = arma::colvec(1); xx1.fill(0.0);
arma::colvec LL = arma::colvec(1); 
arma::colvec R = arma::colvec(1); 
arma::colvec g = arma::colvec(1); g.fill(0.0);
arma::colvec diffnew = arma::colvec(s);diffnew.fill(0.0);
arma::colvec Lv = arma::colvec(s);Lv.fill(LL(0));
arma::colvec Rv = arma::colvec(s);Rv.fill(R(0));
arma::colvec xv = arma::colvec(s);xv.fill(0.0);
arma::colvec ankv = arma::colvec(s);ankv.fill(ank(0));
arma::colvec count = arma::colvec(1); count.fill(0.0);
bool res1 = TRUE;
bool res2 = FALSE;
bool res3 = FALSE;
int g1 = 0;
int g3 = 0;
NumericVector anok; NumericVector ankk;
arma::colvec lLnew = arma::colvec(1);
arma::colvec r = arma::colvec(1);
arma::colvec uu = arma::colvec(1);


// Filling tmpmat with values for each of L eigenfunctions for each of s observations
for (int i=0; i<s; i++) {
	for(int j = 0; j<L;j++){
            tmpmat(i,j) = Rcpp::as<double>(eigenfun(j+1,thetaobs[i]));
	}
}


for(int i = 0; i<s; i++){
	if(demean(i) < mu(i)){
		if(intensityobs(i) == 1.0){
			piin1(0) = piin1(0) + 1.0;
		}
	}
}

for(int i = 0; i<s; i++){
	if(demean(i) < mu(i)){
		piin2(0) = piin2(0) + 1.0;
	}
}

for(int i = 0; i<s; i++){
	if(demean(i) >= mu(i)){
		if(intensityobs(i) == 1.0){
			piout1(0) = piout1(0) + 1.0;
		}
	}
}

for(int i = 0; i<s; i++){
	if(demean(i) >= mu(i)){
		piout2(0) = piout2(0) + 1.0;
	}
}

piinini = piin1 / piin2;
pioutini = piout1 / piout2;


calc1 = 2*M_PI*exp(-2*lambdaini);
for(int i=0; i<(i_J+1); i++){
	cnini(i) = calc1(0)*Rcpp::as<double>(besselI(max(2*lambdaini,0.0),i));
}

eigencnini(0) = cnini(0);
for(int i=1; i<(i_J+1); i++){
	eigencnini(2*i-1) = cnini(i);
	eigencnini(2*i) = cnini(i);
} 
alphaini = log(piinini*(1-pioutini)/(pioutini*(1-piinini)));
betaini = log((1 - piinini)/(1 - pioutini));
for(int i = 0; i<s; i++){
	if(diffini(i)<0){
		tmp(i) = 1;
	}
}

nin = sum(tmp);
for(int i=0; i<s; i++){
	if(intensityobs(i)==1){
	ninone = ninone + tmp(i);
	}
}

//main loop
for(int i=0; i<(i_nrun+i_nburn); i++){
for(int k=0; k<L; k++){
	eigencnk(0) = eigencnini(k);
	ank(0) = anini(k);
	tmpmatk = tmpmat.col(k);
	gx0 = ninone*alphaini+nin*betaini-(((pow(ank,2))/eigencnk)*tauinirg/2);
	
	//Slice sampling of kth element of z
	if(Slice){
 		rexpval = rexp(1);
		logy(0) = gx0(0) - rexpval(0);
		xx1.fill(0.0);
		rexpval = runif(1, 0, 1.0);
		LL(0) = ank(0) - rexpval[0];
		R = LL + 1.0;
		g.fill(0.0);
		diffnew.fill(0.0);
		Lv.fill(LL(0));
		Rv.fill(R(0));
		xv.fill(0.0);
		ankv.fill(ank(0));
		count.fill(0.0);
		res1 = TRUE;
		res2 = FALSE;
		res3 = FALSE;
		g1 = 0;
		g3 = 0;
		while( res1 ){
            	count = count+1;
			res1 = count(0) < 100.0;
			res2 = LL(0)<=-10000;
			if(res2){
				LL(0) = LL(0)+1;
				res1 = FALSE;
				}
			else {
				Lv.fill(LL(0));
				diffnew = diffini - ((Lv - ankv) % tmpmatk);
				g1 = 0; g3 = 0;
				for(int i=0; i<s;i++){
					if(diffnew(i)<=0){
						g3 = g3+1;
						if(intensityobs(i)==1){
							g1 = g1+1;
						}
					}
				}
			g = g1*alphaini+g3*betaini-((pow(LL,2))/eigencnk)*tauinirg/2;
       		res3 = g(0) <= logy(0);
			}
          		if (res3){ 
			LL(0) = LL(0) + 1.0;
			res1=FALSE;}
           		LL(0) = LL(0) - 1.0;
		}

		res2 = FALSE;
		res3 = FALSE;
		count = 0.0;
		res1 = TRUE;
      	while( res1 ){
            	count=count+1.0;
			res1 = count(0) < 100.0;
			res2 = R(0)>=10000.0;
			if(res2){
				R(0) = R(0) - 1.0;
				res1 = FALSE;
			}
			else {
				Rv.fill(R(0));
				diffnew = diffini - ((Rv - ankv) % tmpmatk);
				g1 = 0; g3 = 0;
				for(int i=0; i<s;i++){
					if(diffnew(i)<=0){
						g3 = g3+1;
						if(intensityobs(i)==1){
							g1 = g1+1;
						}
					}
				}
				g = g1*alphaini+g3*betaini-((pow(R,2))/eigencnk)*tauinirg/2;
				res3 = g(0) <= logy(0);
      		}      
			if (res3){ 
            		R(0)=R(0)-1.0;
				res1 = FALSE;}
            		R(0) = R(0) + 1.0;
          		}
			res1 = (LL(0)<-10000.0);
    			if (res1) {
       			LL(0) = -10000.0;
   			}
			res1 = (R(0)>10000.0);
    			if (res1) {
        			R(0) = 10000.0;
    		}
		count = 0.0;
		res1 = TRUE;
		res2 = FALSE;
		res3 = FALSE;
    		while(res1) {
			count=count+1;
			res1 = count(0) < 200.0 ;
			if(res2){
				res1 = FALSE;
			}
			else{
        			xx1 = runif(1, LL(0), R(0));
				xv.fill(xx1(0));
				diffnew = diffini - ((xv - ankv) % tmpmatk);
	     			g1 =0; g3=0;
              		for(int i=0; i<s;i++){
					if(diffnew(i)<=0){
						g3 = g3+1;
					if(intensityobs(i)==1){
						g1 = g1+1;
					}
				}
			}
        		g = g1*alphaini+g3*betaini-((pow(xx1,2))/eigencnk)*tauinirg/2;
	   		res3 = (xx1(0) > ank(0));
			}
 			res2 = (g(0) >= logy(0));
        		if (res3) {
            		R(0) = xx1(0);
        		}
        		else {
            		LL(0) = xx1(0);
        		}
    		}  

		anini(k) = xx1(0);
		ninone = g1;
		nin = g3;
		diffini = diffnew;
	}// begin MH sampling of kth element of z
	else{
		g1 = 0; g3 = 0;											
		anok[0] = anini(k);
		ankk = rnorm(1, anini(k), 0.05); 
		Lv.fill(ankk[0]);
		ankv.fill(anok[0]);
		diffnew = diffini - ((Lv - ankv) % tmpmatk);
		g1 = 0; g3 = 0;
		for(int i=0; i<s;i++){
			if(diffnew(i)<=0){
				g3 = g3+1;
				if(intensityobs(i)==1){
					g1 = g1+1;
				}
			}
		}
		lLnew = g1*alphaini+g3*betaini-((pow(ankk[0],2))/eigencnk)*tauinirg/2;
		r = dnorm(ankk, anok[0],.05) - dnorm(anok,ankk[0],.05);
		r = r + lLnew - gx0;
      	r(0) = fmin(exp(r(0)), 1.0);
		uu = runif(1);
      	if(uu(0) <= r(0)) {
			ninone = g1;
			nin = g3;
			diffini = diffnew;
			anini(k) = ankk[0];									// update z, nin, and loglikelihood if sample is accepted
			gx0 = lLnew;
      	}
	}
}// end of sampling of z

astar = lambdaini + L/2;
interim = anini.t()*(anini / eigencnini);
bstar = betatau + interim/2;
tauinirg = rgamma(1,astar(0),bstar(0));
rmat.fill(0);
rmat = tmpmat*anini + mu;
for(int j = 0; j< s; j++){
	if(demean(j)<=rmat(j)){tmpp(j)=1.0;}
	else{tmpp(j)=0.0;}
}
nin = sum(tmpp);
ninone = sum(intensityobs%tmpp);
nout = s - nin;
noutone = sum(intensityobs) - ninone;

x1 = rbeta(1, ninone, nin - ninone);
x2 = rbeta(1, noutone, nout - noutone);

piinini = arma::max(x1, x2);
pioutini = arma::min(x1, x2);

alphaini = log(piinini * (1 - pioutini)/(pioutini *(1 - piinini)));
betaini = log((1 - piinini)/(1 - pioutini));

gx0 = -1/2 * (sum(log(eigencnini)) + tauinirg * interim) + (alphalambda - 1) * log(lambdaini) - betalambda * lambdaini;

lambdalist = unisliceL(lambdaini, gx0, i_J, tauinirg, anini,  alphalambda,  betalambda, lambdaini);
lambdaini = Rcpp::as<NumericVector>(lambdalist["x1"]);

if(i > i_nburn){
ansum = ansum + anini;
ansmp.col(i-i_nburn) = anini; 
}

}

ansum = ansum/i_nrun;

arma::colvec thetaplot = arma::colvec(200);
for(int k = 0; k<200; k++){
	thetaplot(k) = 2.0*M_PI*(k/200.0); 
}
arma::mat estfunc = arma::mat(200,L);
arma::colvec esttheta = arma::colvec(200);
double est = 0.0;

for(int k = 0; k<200; k++){
		est=0.0;
  		for(int j = 0; j<L; j++){
			estfunc(k,j) = Rcpp::as<double>(eigenfun(j+1,thetaplot(k)));
			est = est + Rcpp::as<double>(eigenfun(j+1,thetaplot(k)))*ansum(j)+(d_inimean/L);
		}
		esttheta(k) =est;
}

arma::mat estthetapts = arma::mat(200,i_nrun);
arma::mat estpts = arma::mat(200,i_nrun);
arma::colvec mutheta = arma::colvec(200);mutheta.fill(d_inimean);

for(int i = 0; i<i_nrun; i++){
		estpts.col(i) = estfunc*ansmp.col(i)+mutheta;
		estthetapts.col(i) = esttheta;
}
arma::colvec variance = arma::colvec(200);
variance = sum(pow(estpts-estthetapts,2),1)/(i_nrun-1.0);
for(int i = 0; i<i_nrun; i++){
		estpts.col(i) = (estpts.col(i) - estthetapts.col(i))/sqrt(variance);
}

arma::colvec sortval = arma::colvec(200);
arma::colvec sorted = arma::colvec(200);
for(int i = 0; i<200; i++){
sorted = trans(sort(estpts.row(i)));
sortval(i) = sorted(floor(.95*i_nrun));
}
arma::colvec lower = arma::colvec(200);
arma::colvec upper = arma::colvec(200);
lower = esttheta - sortval%sqrt(variance);
upper = esttheta + sortval%sqrt(variance);

return Rcpp::List::create(Rcpp::Named("estimate") = esttheta,Rcpp::Named("theta") = thetaplot,Rcpp::Named("lower") = lower,Rcpp::Named("upper") = upper);
}')



# triangle2 produces a triangular boundary for use in simulations

triangle2 = function(S){
	triangle.scalar <- function(theta, h) {
	r=0
        if (any(theta >= 0 & theta <  pi/2, theta>= 11*pi/6 & theta < 2*pi)) {
	      h = S*sin(pi/3)
            k = S*cos(pi/3)
		hstar = k*tan(pi/6)
		hh = h - hstar
		r = hh / ((sin(theta) + (h/k)*cos(theta)))
        }
        if (theta>= pi/2 & theta < 7*pi/6) {
            theta = pi - theta	
	      h = S*sin(pi/3)
		k = S*cos(pi/3)
		hstar = k*tan(pi/6)
		hh = h - hstar
		r = hh / ((sin(theta) + (h/k)*cos(theta)))
        }
        if (theta>= 7*pi/6 & theta < 3*pi/2) {
           a = 3*pi/2-theta
           h = S*sin(pi/3)
		k = S*cos(pi/3)
		hstar = k*tan(pi/6)
	     r = (hstar)/cos(a) 
        }
        if (theta>=3*pi/2 & theta< 11*pi/6) {
           a = theta-3*pi/2
           h = S*sin(pi/3)
			k = S*cos(pi/3)
		hstar = k*tan(pi/6)
	     r = (hstar)/cos(a) 
        }
        return(r)
    }
    ret = function(theta) c(sapply(theta, function(theta) triangle.scalar(theta, 
        h)))
    return(ret)	
}

# Example 1: R code only.  
set.seed(12345)
gamma.fun = ellipse(a = 0.35, b = 0.25)
obs = par2obs(m = 100, pi.in = 0.5, pi.out = 0.2, design = 'J', gamma.fun)
rotate <- function(x) t(apply(x, 2, rev))  # rotate closewise by 90 degrees
image(rotate(obs$intensity), axes = FALSE, asp = 1, main = 'observation')
t1 = proc.time()
rbinary = BayesBD.binary(obs, ini.mean = 0.4, n.run = 5000, n.burn = 1000, J = 10, output.all = FALSE) 
t2 = proc.time()
t2-t1
theta.plot = seq(from = 0, to = 2*pi, length.out = 200)
plot.val = rbinary$gamma.hat(theta.plot)
x.plot = plot.val*cos(theta.plot)+.5
y.plot = plot.val*sin(theta.plot)+.5
lines(x.plot, y.plot, lwd=2)




# Example 2: c++ only.  BayesBD is used to run the entire sampling process within c++.
set.seed(12345)
par(mfrow = c(1, 2))
gamma.fun = ellipse(a = 0.35, b = 0.25)
obs = par2obs(m = 100, pi.in = 0.5, pi.out = 0.2, design = 'J', gamma.fun)
rotate <- function(x) t(apply(x, 2, rev))  # rotate closewise by 90 degrees
image(rotate(obs$intensity), axes = FALSE, asp = 1, main = 'observation')
t1 = proc.time()
cppsamp = BayesBDbinary(obs, .4, 4000, 1000, 10, TRUE)
t2 = proc.time()
t2-t1
x = cppsamp$estimate*cos(cppsamp$theta)+obs$center[1]
y = cppsamp$estimate*sin(cppsamp$theta)+obs$center[2]
lines(x,y, lty = 2, lwd = 3)
theta.plot = seq(from = 0, to = 2*pi, length.out = 200)
my.radial = function(r, theta, ...){
radial.plot(c(r[order(theta)]), c(theta[order(theta)]),
rp.type = "p", show.grid.label = TRUE, radial.lim = c(0, 0.5),
...)
}
my.radial(gamma.fun(theta.plot), theta.plot, line.col = 1, lty = 1, lwd = 1, show.grid = FALSE)
x = cppsamp$upper*cos(cppsamp$theta)
y = cppsamp$upper*sin(cppsamp$theta)
polygon(x, y,fillOddEven = TRUE, col = 'gray', border = NA)
x = cppsamp$lower*cos(cppsamp$theta)
y = cppsamp$lower*sin(cppsamp$theta) 
polygon(x, y,fillOddEven = TRUE, col = 'white', border = NA)
x = cppsamp$estimate*cos(cppsamp$theta)
y = cppsamp$estimate*sin(cppsamp$theta)
lines(x,y, lty = 2, lwd = 3)






# Simulation results (average of 100 runs): on an Intel Core i7-4790K CPU @ 4.00 GHz with 16 GB RAM running RGui 64-bit on Windows 10
#         				
# c++ only, slice       user      system    elapsed    	Lebesgue error  
# B2 50/20, 100 obs     99.5254   0.0220    100.0924        0.008270191(0.00286151)  
# B3 50/20, 100 obs     81.4828   0.0160    82.0585         0.01576499(0.003118825)
#
# R code, slice
# B2 50/20, 100 obs	374.6639  0.0276    375.2352        0.007264367(0.002503685)
# B3 50/20, 100 obs     245.4681  0.0168    246.0253        0.01638479(0.002954702)
#
# c++ code, MH
# B2 50/20, 100 obs      58.0838  0.0080     58.2627		0.0102668(0.005195168)
# B3 50/20, 100 obs      45.4275  0.0066     45.4909		0.01770454(0.004664789)
#
# c++ code, slice
# B2 25/20, 500 obs    3780.3389  3.0575   3789.4335        0.008900468(0.002847602)
# B3 25/20, 500 obs    3536.0876  3.1815   3545.1834		0.01659544(0.003679925)


