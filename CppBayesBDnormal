##########################################################################################
#  Author: Nicholas Syring
#  Title: BayesBD
#  Contact: nasyring@ncsu.edu; GitHub nasyring
##########################################################################################  	

# Requirements:
#               1. The libraries below.
#               2. A c++ compiler.
#               3. RTools.
#               4. R 3.2+ recommended.


# Directions:
#		1.  Make sure you meet the requirements above.
#		2.  Load the libraries below.
#		3.  Load the functions into your R session: BayesBD.norm, mhstep,
#		    unisliceL, eigenfun, and BayesBDnorm.
#		4.  Run the examples at the end of the code.  There are three examples
#		    comparing the runtime of R code, c++ within and R loop, and pure c++.



# Required libraries.  

library(BayesBD)
library(Rcpp)
library(RcppArmadillo)
library(inline)

# This is an edited version of BayesBD.binary, a function appearing in the BayesBD
# library.  This function produces posterior samples for data from Gaussian images.  

BayesBD.norm = function (obs, ini.mean, n.run = 10000, n.burn = 1000, 
    J = 10, output.all = FALSE) 
{
    mu.fun <- function(theta) theta * 0 + ini.mean
    mu = c(mu.fun(obs$theta.obs))
    L = 2 * J + 1
    alpha.tau = 500
    beta.tau = 1
    alpha.lambda = 2
    beta.lambda = 1
    obs$demean = obs$r.obs - mu
    tmp.mat = sapply(1:L, function(k) eigen.fun(k)(c(obs$theta.obs)))
    an.smp = matrix(NA, L, n.run)
    par.smp = matrix(NA, 4, n.run)
    tau.smp = rep(NA, n.run)
    lambda.smp = rep(NA, n.run)
    an.ini = rep(0, L)
	n.all = length(obs$intensity)
    in.ini = (obs$r.obs < mu)
    m0 = mean(obs$intensity)	
    v0 = 1/var(as.vector(obs$intensity))
    m1.ini = sum(in.ini * obs$intensity)/sum(in.ini)
    m2.ini = sum((!in.ini) * obs$intensity)/sum(!in.ini)
    s1.ini = sd(as.vector(obs$intensity)[as.vector(in.ini)==TRUE])
    s2.ini = sd(as.vector(obs$intensity)[as.vector(in.ini)==FALSE])
    tau.ini = 500
    lambda.ini = 1
    cn.ini = sapply(0:J, function(ith) 2 * pi * exp(-2 * lambda.ini) * 
        besselI(2 * lambda.ini, ith))
    eigen.cn.ini = rep(cn.ini, each = 2)[-1]
    diff.ini = obs$demean - c(tmp.mat %*% an.ini)
    tmp = (diff.ini < 0)
    n.in <- sum(tmp)
    alpha1.ini = -log(s1.ini) 
	alpha2.ini = - log(s2.ini)
    beta.ini = -((2*((s1.ini)^2))^(-1))*sum(in.ini * ((obs$intensity-m1.ini)^2))-((2*((s2.ini)^2))^(-1))*sum((!in.ini) * ((obs$intensity-m2.ini)^2))
    mh.step <- function(k, an, alpha1,alpha2, beta, eigen.cn, tau,n.in,m1, m2, s1, s2) {
	  ret = list(an = an,n.in = n.in, beta = beta)
        eigen.cn.ini = eigen.cn
        an.old = matrix(an,L,1)
	  an.new.k = rnorm(1,an.old[k],.1)
	  an.new = an.old
	  an.new[k,1] = an.new.k
	  lL.old = n.in * alpha1-n.in*alpha2 + beta - t(an.old)%*%solve(diag(eigen.cn.ini))%*%an.old*tau.ini/2 
	  r.mat = c(tmp.mat %*% an.new + mu)
        tmp <- (obs$r.obs <= r.mat)
        n.in.new <- sum(tmp)
	  beta.ini = -((2*((s1)^2))^(-1))*sum(tmp * ((obs$intensity-m1)^2))-((2*((s2)^2))^(-1))*sum((!tmp) * ((obs$intensity-m2)^2))
	  lL.new = n.in.new * alpha1-n.in.new*alpha2 + beta.ini - t(an.new)%*%solve(diag(eigen.cn.ini))%*%an.new*tau.ini/2
        r = lL.new - lL.old + dnorm(an.new.k, an.old[k,1],.1) - dnorm(an.old[k,1],an.new.k ,.1)
        R <- min(exp(r), 1)
        if(runif(1) <= R) {
       	ret = list(an = an.new,n.in = n.in.new, beta = beta.ini)
        } 
	  return(ret)
    }

    logL.lambda = function(tau, an) {
        ret = function(lambda) {
            cn = sapply(0:J, function(ith) 2 * pi * exp(-2 * 
                lambda) * besselI(2 * lambda, ith))
            eigen.cn = rep(cn, each = 2)[-1]
            ret2 = -1/2 * (sum(log(eigen.cn)) + tau * sum(an^2/eigen.cn)) + 
                (alpha.lambda - 1) * log(lambda) - beta.lambda * 
                lambda
            return(ret2)
        }
        return(ret)
    }
    start <- proc.time()
    for (ith in 1:n.run) {
	k=1
        for (k in 1:L) {
          		an.n.new = mh.step(k,an.ini, alpha1.ini,alpha2.ini, beta.ini, eigen.cn.ini, tau.ini,n.in, m1.ini, m2.ini, s1.ini, s2.ini)
			n.in = an.n.new$n.in
			an.ini = an.n.new$an
			beta.ini = an.n.new$beta
	        }
	  a.star = alpha.tau + L/2
        b.star = beta.tau + sum(an.ini^2/eigen.cn.ini)/2
        tau.ini = rgamma(1, shape = a.star, rate = b.star)
        r.mat = c(tmp.mat %*% an.ini + mu)
        tmp <- (obs$r.obs <= r.mat)
        n.in <- sum(tmp)
        n.out = length(r.mat) - n.in
	  mean.in = ifelse(sum(tmp)==0,0,sum(tmp*obs$intensity)/n.in)
	  mean.out = ifelse(sum(!tmp)==0,0,sum((!tmp)*obs$intensity)/n.out)
        m1.0 = (n.in/(n.in+1))*mean.in + (1/(n.in+1))*m0
	  m2.0 = (n.out/(n.out+1))*mean.out + (1/(n.out+1))*m0
	  alph1.0 = 10+n.in/2
	  beta1.0 = .1+.5*sum(tmp*((obs$intensity-mean.in)^2)) + (n.in/(1+n.in))*(.5*(mean.in - m0)^2)
        alph2.0 = 10+n.out/2
	  beta2.0 = .11+.5*sum((!tmp)*((obs$intensity-mean.out)^2)) + (n.out/(1+n.out))*(.5*(mean.out - m0)^2)
	  x3 = 1/rgamma(1,shape = alph1.0,rate = beta1.0)
	  x4 = 1/rgamma(1,shape = alph2.0,rate = beta2.0)	  
	  s1.ini = x3^.5
	  s2.ini = x4^.5
	  x1 = rnorm(1,m1.0,sd = s1.ini/sqrt(n.in+1))
        x2 = rnorm(1,m2.0,sd = s2.ini/sqrt(n.out+1))
        m1.ini = x1
	  m2.ini = x2
        alpha1.ini = -log(s1.ini) 
	  alpha2.ini = - log(s2.ini)
        beta.ini = -((2*((s1.ini)^2))^(-1))*sum(tmp * ((obs$intensity-m1.ini)^2))-((2*((s2.ini)^2))^(-1))*sum((!tmp) * ((obs$intensity-m2.ini)^2))
        lambda.ini = uni.slice(lambda.ini, g = logL.lambda(tau = tau.ini, 
            an = an.ini), lower = 0, upper = 100)
        an.smp[, ith] = an.ini
        par.smp[, ith] = c(m1.ini,m2.ini,s1.ini,s2.ini)
        lambda.smp[ith] = lambda.ini
        tau.smp[ith] = tau.ini
        if (ith%%floor(n.run/100) == 1) {
            duration = proc.time() - start
           # cat(ith, "th iteration:", "ETA:", duration[3]/ith * 
            #    (n.run - ith), "\n")
        }
    }
    Total.Time = proc.time() - start
    an.MC = apply(an.smp[, n.burn:n.run], 1, mean)
    gamma.MC <- function(theta.arg) {
        c(sapply(1:L, function(k) eigen.fun(k)(theta.arg)) %*% 
            an.MC + mu.fun(theta.arg))
    }
    result = list(gamma.hat = gamma.MC)
    if (output.all) {
	
plotStuff = function(theta){
	Len = n.run - n.burn
	sum_coords = 0
	var = 0
	u_i = matrix(0,Len,1)
	for(i in 1:Len){
		coords = sapply(1:L, function(k) eigen.fun(k)(theta)) %*% an.smp[, n.burn+i] + mu.fun(theta)
		sum_coords = sum_coords + coords
	}
	mean = sum_coords/1000
	for(i in 1:1000){
		coords = sapply(1:L, function(k) eigen.fun(k)(theta)) %*% an.smp[, n.burn+i] + mu.fun(theta)
		var = var + (coords - mean)^2
	}
	var = var / 1000
	sd = var^.5
	for(i in 1:1000){
		coords = sapply(1:L, function(k) eigen.fun(k)(theta)) %*% an.smp[, n.burn+i] + mu.fun(theta)
		u_i[i,1] = (coords - mean)/sd
	}
	L0 = sort(u_i)[.95*length(u_i)]
	lower = mean - L0*sd
	upper = mean + L0*sd
	x1 = mean * cos(theta)
	y1 = mean * sin(theta)
	lx1 = lower * cos(theta)
	ly1 = lower * sin(theta)
	ux1 = upper * cos(theta)
	uy1 = upper * sin(theta)
return(list(mean = mean, x = x1, y = y1, lx = lx1, ly = ly1, ux = ux1, uy = uy1))
}


        result = list(plotStuff=plotStuff,an.smp = an.smp, par.smp = par.smp, tau.smp = tau.smp, 
            lambda.smp = lambda.smp, gamma.hat = gamma.MC)
    }
    return(result)
}


# This is a c++ function which can be used with the Rcpp package to produce posterior
# samples of the 'z' parameter; see Step 2 and its modifications in Section 5: Sampling 
# Algorithms in Li and Ghosal 2015 for details.  This function is used by another c++
# function, BayesBDnorm, below to loop the posterior sampling process. This version
# does MCMC sampling using Metropolis Hastings within Gibbs

cppFunction(depends = "RcppArmadillo",'Rcpp::List mhstep(int k, arma::mat tmpmat, arma::colvec mu,arma::colvec intensityobs,arma::colvec demean, arma::colvec an, arma::colvec alpha1, arma::colvec alpha2, arma::colvec beta, arma::colvec eigencn, arma::colvec tau, arma::colvec nin, arma::colvec mu1, arma::colvec mu2, arma::colvec sd1, arma::colvec sd2){
RNGScope scope;
	int s = mu.n_rows;
	arma::colvec anoldk = arma::colvec(1); anoldk(0) = an(k);	
	arma::colvec annewk = arma::colvec(1); annewk.fill(0.0);
	arma::colvec annew = an;
	arma::colvec tmp = arma::colvec(s); tmp.fill(0.0);
	arma::colvec lLold = arma::colvec(1); lLold.fill(0.0);
	arma::colvec lLnew = arma::colvec(1); lLnew.fill(0.0);
	arma::colvec rmat = arma::colvec(s); rmat.fill(0.0);
	arma::colvec ninnew = arma::colvec(1); ninnew.fill(0.0);
	arma::colvec std_sum = arma::colvec(1); std_sum.fill(0.0);
	Rcpp::NumericVector r = Rcpp::NumericVector( Rcpp::Dimension(1)); r[0] = 0.0;
	Rcpp::NumericVector lLnewr = Rcpp::NumericVector( Rcpp::Dimension(1)); lLnewr[0] = 0.0;
	Rcpp::NumericVector lLoldr = Rcpp::NumericVector( Rcpp::Dimension(1)); lLoldr[0] = 0.0;
	arma::colvec R = arma::colvec(1); R.fill(0.0);
	arma::colvec uu = arma::colvec(1); uu.fill(0.0);
	annewk = rnorm(1, anoldk(0), 0.05);
	annew(k) = annewk(0);
	Rcpp::List ret = Rcpp::List::create(Rcpp::Named("ank") = anoldk, Rcpp::Named("nin") = nin, Rcpp::Named("beta") = beta, Rcpp::Named("R") = 1234);
	Rcpp::NumericVector nnew = Rcpp::NumericVector( Rcpp::Dimension(1)); nnew[0]=annewk(0);
	Rcpp::NumericVector old = Rcpp::NumericVector( Rcpp::Dimension(1)); old[0]=anoldk(0); 
	lLold = nin * alpha1-nin*alpha2 - beta - an.t()*inv(diagmat(eigencn))*an*tau/2; 
	rmat = tmpmat*annew + mu;
	for(int i = 0; i<s; i++){
		if(demean(i)<rmat(i)){
			tmp(i) = 1;
			std_sum = std_sum + pow(intensityobs(i)-mu1(0),2)/(2.0*pow(sd1(0),2));
		}else{
			std_sum = std_sum + pow(intensityobs(i)-mu2(0),2)/(2.0*pow(sd2(0),2));
		}
	}
	ninnew(0) = sum(tmp);
	lLnew = ninnew * alpha1-ninnew*alpha2 - std_sum - annew.t()*inv(diagmat(eigencn))*annew*tau/2;
	lLnewr[0] = lLnew(0); lLoldr[0] = lLold(0); 
	r = lLnewr - lLoldr + dnorm(nnew, old[0],.05) - dnorm(old,nnew[0],.05);
      R(0) = fmin(exp(r[0]), 1.0);
	uu = runif(1);
      if(uu(0) <= R(0)) {
      	ret = Rcpp::List::create(Rcpp::Named("ank") = annewk, Rcpp::Named("nin") = ninnew, Rcpp::Named("beta") = std_sum, Rcpp::Named("R") = R,Rcpp::Named("uu") = uu,Rcpp::Named("annew") = annew);
      }else{ 
		ret = Rcpp::List::create(Rcpp::Named("ank") = anoldk, Rcpp::Named("nin") = nin, Rcpp::Named("beta") = beta, Rcpp::Named("R") = R,Rcpp::Named("uu") = uu,Rcpp::Named("annew") = annew);
	}
	return(ret);
}')
 

# This is a c++ function which can be used with the Rcpp package to produce posterior
# samples of the 'a' parameter; see Step 5 in Section 5: Sampling Algorithms in Li and Ghosal 2015 for 
# details.  This function is used by another c++ function, BayesBDnorm, below to loop
# the posterior sampling process.

cppFunction('Rcpp::List unisliceL(SEXP x0, SEXP gx0, int i_J, SEXP tauini, SEXP anini, SEXP alphalambda, SEXP betalambda, int lambdaini){
RNGScope scope;
Rcpp::Function eigenfun("eigenfun");
Rcpp::Function besselI("besselI");
double w = 1.0;
Rcpp::NumericVector m = Rcpp::NumericVector( Rcpp::Dimension(1));
 m[0] = 100.0; 
double d_m = 100.0;
Rcpp::NumericVector lower = Rcpp::NumericVector( Rcpp::Dimension(1)); lower[0] = 0.0;
Rcpp::NumericVector upper = Rcpp::NumericVector( Rcpp::Dimension(1)); upper[0] = 500.0;
   Rcpp::NumericVector logy = Rcpp::NumericVector( Rcpp::Dimension(1)); logy = Rcpp::as<NumericVector>(gx0) - rexp(1);
   Rcpp::NumericVector u = Rcpp::NumericVector( Rcpp::Dimension(1)); u = runif(1, 0, w);
    Rcpp::NumericVector L = Rcpp::NumericVector( Rcpp::Dimension(1)); L = lambdaini - u;
    Rcpp::NumericVector R = Rcpp::NumericVector( Rcpp::Dimension(1)); R = lambdaini + (w - u);
    Rcpp::NumericVector L2 = Rcpp::NumericVector( Rcpp::Dimension(1)); L2=L;
    Rcpp::NumericVector R2 = Rcpp::NumericVector( Rcpp::Dimension(1)); R2=R;
	Rcpp::NumericVector J = Rcpp::NumericVector( Rcpp::Dimension(1)); J = 0.0;
	Rcpp::NumericVector K = Rcpp::NumericVector( Rcpp::Dimension(1)); K = 0.0;
Rcpp::LogicalVector LL = Rcpp::LogicalVector( Rcpp::Dimension(1));
Rcpp::LogicalVector RR = Rcpp::LogicalVector( Rcpp::Dimension(1));
Rcpp::NumericVector ggL = Rcpp::NumericVector( Rcpp::Dimension(1)); ggL=0.0;
Rcpp::NumericVector ggR = Rcpp::NumericVector( Rcpp::Dimension(1)); ggR=0.0;
Rcpp::LogicalVector gg1 = Rcpp::LogicalVector( Rcpp::Dimension(1));
Rcpp::LogicalVector gxy = Rcpp::LogicalVector( Rcpp::Dimension(1));
Rcpp::NumericVector x1 = Rcpp::NumericVector( Rcpp::Dimension(1));
Rcpp::NumericVector gx1 = Rcpp::NumericVector( Rcpp::Dimension(1));
Rcpp::NumericVector gxF = Rcpp::NumericVector( Rcpp::Dimension(1));
Rcpp::LogicalVector x10 = Rcpp::LogicalVector( Rcpp::Dimension(1));
Rcpp::NumericVector count = Rcpp::NumericVector( Rcpp::Dimension(1)); count=0.0;
Rcpp::NumericVector interim = Rcpp::NumericVector( Rcpp::Dimension(1));interim[0] = 0.0;
Rcpp::NumericVector cnini = Rcpp::NumericVector( Rcpp::Dimension(i_J+1));
Rcpp::NumericVector eigencnini = Rcpp::NumericVector( Rcpp::Dimension(2*i_J+1));
Rcpp::NumericVector calc1 = Rcpp::NumericVector( Rcpp::Dimension(1));calc1[0] = 0.0;
bool res = TRUE;
NumericVector v_anini = Rcpp::as<NumericVector>(anini);
NumericVector v_x0 = Rcpp::as<NumericVector>(x0);
bool resL = FALSE;
bool resR = FALSE;
bool resg = FALSE;
bool res1 = FALSE;


	
        J = floor(runif(1, 0.0, d_m));
        K = (m - 1) - J;
		count = 0.0;
while( res ){
		interim[0]=0.0;
            count = count+1;
		res = is_true( all( count < J ) );
		calc1 = 2*M_PI*exp(-2*L);
		for(int i=0; i<(i_J+1); i++){
				cnini[i] = calc1[0]*Rcpp::as<double>(besselI(pmax(2*L,0),i));
			}
			eigencnini[0] = cnini[0];
			for(int i=1; i<(i_J+1); i++){
				eigencnini[2*i-1] = cnini[i];
				eigencnini[2*i] = cnini[i];
			}
			for(int i=0; i<(2*i_J+1);i++){
				interim[0] = interim[0] + (v_anini[i])*(v_anini[i])/eigencnini[i];
			}
			ggL = -1/2 * (sum(log(eigencnini)) + Rcpp::as<NumericVector>(tauini) * interim) + (Rcpp::as<NumericVector>(alphalambda) - 1) * log(L) - Rcpp::as<NumericVector>(betalambda) * L;
		 resL = (L[0]<=lower[0]);
            if (resL){ 
			L2 = L;
			res= FALSE;}
		 resg = (ggL[0] <= logy[0]);
            if (resg){ 
			L2 = L;
			res=FALSE;}
            L = L - w;
            }
		count = 0.0;
		res = TRUE;
       while( res ){
		interim[0]=0.0;
            count = count+1;
		res = is_true( all( count < K ) );
		calc1 = 2*M_PI*exp(-2*R);
		for(int i=0; i<(i_J+1); i++){
				cnini[i] = calc1[0]*Rcpp::as<double>(besselI(pmax(2*R,0),i));
			}
			eigencnini[0] = cnini[0];
			for(int i=1; i<(i_J+1); i++){
				eigencnini[2*i-1] = cnini[i];
				eigencnini[2*i] = cnini[i];
			}
			for(int i=0; i<(2*i_J+1);i++){
				interim[0] = interim[0] + (v_anini[i])*(v_anini[i])/eigencnini[i];
			}
			ggR = -1/2 * (sum(log(eigencnini)) + Rcpp::as<NumericVector>(tauini) * interim) + (Rcpp::as<NumericVector>(alphalambda) - 1) * log(R) - Rcpp::as<NumericVector>(betalambda) * R;
		 resR = (R[0]<=lower[0]);
            if (resR){ 
			R2 = R;
			res= FALSE;}
		 resg = (ggR[0] <= logy[0]);
            if (resg){ 
			R2 = R;
			res=FALSE;}
            R = R + w;
            }
		
	resL = (L2[0]<lower[0]);
    if (resL) {
        L2 = lower;
    }
	resR = (R2[0]>upper[0]);
    if (resR) {
        R2 = upper;
    }
	count = 0.0;
	res = TRUE;
    while(res) {
		interim[0]=0.0;
		count=count+1;
		res = is_true( all( count < 100 ) );
      	  x1 = runif(1, L2[0], R2[0]);
			calc1 = 2*M_PI*exp(-2*x1);
			for(int i=0; i<(i_J+1); i++){
				cnini[i] = calc1[0]*Rcpp::as<double>(besselI(pmax(2*R,0),i));
			}
			eigencnini[0] = cnini[0];
			for(int i=1; i<(i_J+1); i++){
				eigencnini[2*i-1] = cnini[i];
				eigencnini[2*i] = cnini[i];
			}
			for(int i=0; i<(2*i_J+1);i++){
				interim[0] = interim[0] + (v_anini[i])*(v_anini[i])/eigencnini[i];
			}
			gx1 = -1/2 * (sum(log(eigencnini)) + Rcpp::as<NumericVector>(tauini) * interim) + (Rcpp::as<NumericVector>(alphalambda) - 1) * log(x1) - Rcpp::as<NumericVector>(betalambda) * x1;
	  resg = (gx1[0] >= logy[0]);
        if (resg){ 
            gxF=gx1;
		res = FALSE;
			}
		res1 = (x1[0] > v_x0[0]);
        if (res1) {
            R2 = x1;
        }
        else {
            L2 = x1;
        }
    }  
 	return Rcpp::List::create(Rcpp::Named("x1") = x1);


}')


# This c++ function computes the nth eigenfunction of the SEP kernel.  It is used by
# BayesBDbinary below.


cppFunction('double eigenfun(int n, double x) { 
	int k1 = n%2;
    	double k2 = (n - k1)/2;
	double ret = 0;
   	if (n == 1) {
       		 ret = 1/sqrt(2 * M_PI) + 0 * x;
    	}
    	if (n > 1) {
        	if (k1 == 0) {
            		 ret = 1/sqrt(M_PI) * cos(k2 * x);
        	}
       		if (k1 == 1) {
            		 ret = 1/sqrt(M_PI) * sin(k2 * x);
       		}
    }
    return ret;
}')

# This c++ function is a translation to c++ of the BayesBD.norm R function above.  It
# produces posterior samples of the boundary of a Gaussian image.  The output is a set of
# boundary values at 200 points, to be plotted on the image. 

cppFunction(depends = "RcppArmadillo",'Rcpp::List BayesBDnormal(SEXP obs, SEXP inimean, SEXP nrun, SEXP nburn, SEXP J) { 

// Including additional user-defined Rcpp functions
RNGScope scp;
Rcpp::Function eigenfun("eigenfun");
Rcpp::Function besselI("besselI");
Rcpp::Function mhstep("mhstep");
Rcpp::Function unisliceL("unisliceL");

// Extracting the inputs
Rcpp::List 		      	obsL(obs);
arma::mat thetaobs 	 	= Rcpp::as<arma::mat>(obsL["theta.obs"]);
arma::colvec demean 	 	= Rcpp::as<arma::colvec>(obsL["r.obs"]);
arma::colvec intensityobs     = Rcpp::as<arma::colvec>(obsL["intensity"]);
int i_nrun 				= Rcpp::as<int>(nrun);
int i_nburn				= Rcpp::as<int>(nburn);
int i_J				= Rcpp::as<int>(J);
double d_inimean 			= Rcpp::as<double>(inimean);

// Declaring variables 
Rcpp::List temp2del;
Rcpp::List lambdalist;

int s					= thetaobs.size();
int L                  		= 2*i_J+1;
int betatau           		= 1;
int alphalambda      		= 2;
int betalambda       		= 1;
int nin = 0;
int nout = 0;


arma::colvec tmpmatk		= arma::colvec(s); tmpmatk.fill(0.0);
arma::colvec mu			= arma::colvec(s); mu.fill(d_inimean);
arma::colvec v_demean         = demean - mu;
arma::colvec diffini 		= v_demean; 
arma::colvec eigencnk   	= arma::colvec(1); eigencnk.fill(0.0);
arma::colvec ank   	      = arma::colvec(1); ank.fill(0.0); 
arma::colvec astar   	      = arma::colvec(1); astar(0)=0.0;
arma::colvec bstar   	      = arma::colvec(1); bstar(0)=0.0;
arma::colvec tauinirg   	= arma::colvec(1); tauinirg(0)=500.0;
arma::colvec mu0 		      = arma::colvec(1); mu0 = sum(intensityobs)/s;
arma::colvec sd0 		      = arma::colvec(1); sd0.fill(1000.0);
arma::colvec mu1 		      = arma::colvec(1); mu1(0) = mu0(0);
arma::colvec mu2 		      = arma::colvec(1); mu2(0) = mu0(0);
arma::colvec sd1 		      = arma::colvec(1); sd1(0) = sd0(0);
arma::colvec sd2 		      = arma::colvec(1); sd2(0) = sd0(0);
arma::colvec xbarin 		= arma::colvec(1); xbarin.fill(0.0);
arma::colvec xbarout 		= arma::colvec(1); xbarout.fill(0.0);
arma::colvec xinsum 		= arma::colvec(1); xinsum.fill(0.0);
arma::colvec xoutsum 		= arma::colvec(1); xoutsum.fill(0.0);
arma::colvec xinsumsq 		= arma::colvec(1); xinsumsq.fill(0.0);
arma::colvec xoutsumsq 		= arma::colvec(1); xoutsumsq.fill(0.0);
arma::colvec ssin 		= arma::colvec(1); ssin.fill(0.0);
arma::colvec ssout 		= arma::colvec(1); ssout.fill(0.0);
arma::colvec calc1 		= arma::colvec(1); calc1.fill(0.0);
arma::colvec std_sum 		= arma::colvec(1); std_sum.fill(0.0);
arma::colvec lambdaini 		= arma::colvec(1); lambdaini(0)=1.0;
arma::colvec anini 		= arma::colvec(L); anini.fill(0.0);
arma::colvec cnini            = arma::colvec(i_J+1); cnini.fill(0.0);
arma::colvec eigencnini       = arma::colvec(L); eigencnini.fill(0.0);
arma::colvec tmp2del2         = arma::colvec(1); tmp2del2.fill(0.0);
arma::colvec interim          = arma::colvec(1); interim.fill(0.0);
arma::colvec rmat             = arma::colvec(s); rmat.fill(0.0);
arma::colvec tmpp             = arma::colvec(s); tmpp.fill(0.0);
arma::colvec tmp              = arma::colvec(s); tmp.fill(0.0);
arma::colvec gx0              = arma::colvec(1); gx0.fill(0.0);
arma::colvec ansum		= arma::colvec(L); ansum.fill(0.0);


arma::mat tmpmat              = arma::mat(s,L); tmpmat.fill(0.0);

// Filling tmpmat with values for each of L eigenfunctions for each of s observations
for (int i=0; i<s; i++) {
	for(int j = 0; j<L;j++){
            tmpmat(i,j) = Rcpp::as<double>(eigenfun(j+1,thetaobs[i]));
	}
}


calc1 = 2*M_PI*exp(-2*lambdaini);
for(int i=0; i<(i_J+1); i++){
	cnini(i) = calc1(0)*Rcpp::as<double>(besselI(max(2*lambdaini,0.0),i));
}

eigencnini(0) = cnini(0);
for(int i=1; i<(i_J+1); i++){
	eigencnini(2*i-1) = cnini(i);
	eigencnini(2*i) = cnini(i);
} 

for(int i = 0; i<s; i++){
	if(diffini(i)<0){
		tmp(i) = 1;
	}
}

nin = sum(tmp);
nout = s - nin;

for(int i=0; i<s;i++){
	if(diffini(i)<=0){
		std_sum = std_sum + pow(intensityobs(i)-mu1(0),2)/(2.0*pow(sd1(0),2));
	}else{
		std_sum = std_sum + pow(intensityobs(i)-mu2(0),2)/(2.0*pow(sd2(0),2));
	}	
}

Rcpp::NumericVector thetaplot = Rcpp::NumericVector( Rcpp::Dimension(200));
for(int k = 0; k<200; k++){
 thetaplot[k] = 2.0*M_PI*(k/200.0); 
}
Rcpp::NumericVector estfunc = Rcpp::NumericVector( Rcpp::Dimension(1));
Rcpp::NumericVector esttheta = Rcpp::NumericVector( Rcpp::Dimension(200));

//main loop
for(int i=0; i<(i_nrun+i_nburn); i++){
for(int k=0; k<L; k++){
		eigencnk(0) = eigencnini(k);
		ank(0) = anini(k);
		tmpmatk = tmpmat.col(k);
		gx0 = -nin*(log(sd1(0))-log(sd2(0))) - std_sum - ((pow(ank,2))/eigencnk(0))*(tauinirg(0)/2);
		temp2del = mhstep(k, tmpmat, mu, intensityobs, demean, anini, -log(sd1(0)),-log(sd2(0)), std_sum, eigencnini, tauinirg, nin, mu1, mu2, sd1, sd2);
		anini(k) = Rcpp::as<double>(temp2del["ank"]);
		nin = Rcpp::as<int>(temp2del["nin"]);
		std_sum = Rcpp::as<arma::colvec>(temp2del["beta"]);
	}
astar = lambdaini + L/2;
interim = anini.t()*(anini / eigencnini);
bstar = betatau + interim/2;
tauinirg = rgamma(1,astar(0),bstar(0));
rmat.fill(0);
rmat = tmpmat*anini + mu;
xinsum(0) = 0.0;
xoutsum(0) = 0.0;
xinsumsq(0) = 0.0;
xoutsumsq(0) = 0.0;
for(int j = 0; j< s; j++){
	if(demean(j)<=rmat(j)){tmpp(j)=1.0;xinsum(0) = xinsum(0) + intensityobs(j);xinsumsq(0) = xinsumsq(0) + pow(intensityobs(j),2);}
	else{tmpp(j)=0.0;xoutsum(0) = xoutsum(0) + intensityobs(j);xoutsumsq(0) = xoutsumsq(0) + pow(intensityobs(j),2);}
}
nin = sum(tmpp); nout = s - nin;
xbarin(0) = xinsum(0)/nin; xbarout(0) = xoutsum(0)/nout;
ssin(0) = (xinsumsq(0) - pow(xinsum(0),2)/nin)/2;
ssout(0) = (xoutsumsq(0) - pow(xoutsum(0),2)/nout)/2;

sd1 = pow(1/rgamma(1, 0.01 + nin/2, 1/(0.01+ssin(0) + (nin/(nin+1))*(pow(xbarin(0) - mu0(0),2.0)/2))),0.5);
sd2 = pow(1/rgamma(1, 0.01 + nout/2, 1/(0.01+ssout(0) + (nout/(nout+1))*(pow(xbarout(0) - mu0(0),2.0)/2))),0.5);
mu1 = rnorm(1,mu0(0)/(nin+1) + nin*xbarin(0)/(nin+1), sd1(0)/pow(nin+1.0,0.5));
mu2 = rnorm(1,mu0(0)/(nout+1) + nout*xbarout(0)/(nout+1), sd2(0)/pow(nout+1.0,0.5));

std_sum.fill(0.0);
for(int i=0; i<s;i++){
	if(demean(i)<=rmat(i)){
		std_sum = std_sum + pow(intensityobs(i)-mu1(0),2)/(2.0*pow(sd1(0),2));
	}else{
		std_sum = std_sum + pow(intensityobs(i)-mu2(0),2)/(2.0*pow(sd2(0),2));
	}	
}

gx0 = -1/2 * (sum(log(eigencnini)) + tauinirg * interim) + (alphalambda - 1) * log(lambdaini) - betalambda * lambdaini;
lambdalist = unisliceL(lambdaini, gx0, i_J, tauinirg, anini,  alphalambda,  betalambda, lambdaini);
lambdaini = Rcpp::as<NumericVector>(lambdalist["x1"]);

if(i > i_nburn){
ansum = ansum + anini;
}

}

ansum = ansum/i_nrun;
for(int k = 0; k<200; k++){
		estfunc[0]=0.0;
  		for(int j = 0; j<L; j++){
			estfunc[0] = estfunc[0] + Rcpp::as<double>(eigenfun(j+1,thetaplot[k]))*ansum(j)+(d_inimean/L);
		}
		esttheta[k] =estfunc[0]+esttheta[k];
}


return Rcpp::List::create(Rcpp::Named("esttheta") = esttheta,Rcpp::Named("thetaplot") = thetaplot);
}')



# Examples: What follows are examples of using R code only, an R loop with c++ sampling,
# and c++ only to produce boundary estimates for binary images.  We set the seed before
# each example to use the same data, and we compute the runtime for comparison. 

# Load this function.  This will be used to su=imulate image data.

parnormobs = function (m, mu.in, mu.out, sd.in, sd.out, design, gamma.fun) {
    center = c(0.5, 0.5)
    obs <- matrix(NA, m, m)
    if (design == "D") {
        x.axis = (col(obs) - 1)/m + 1/(2 * m)
        y.axis = (m - row(obs))/m + 1/(2 * m)
    }
    if (design == "J") {
        x.axis = (col(obs) - 1)/m + 1/(2 * m) + runif(m^2, min = -1/(2 * 
            m), max = 1/(2 * m))
        y.axis = (m - row(obs))/m + 1/(2 * m) + runif(m^2, min = -1/(2 * 
            m), max = 1/(2 * m))
    }
    r.obs = sqrt((x.axis - center[1])^2 + (y.axis - center[2])^2)
    theta.obs <- atan2(y.axis - 1/2, x.axis - 1/2)
    theta.obs[theta.obs < 0] = theta.obs[theta.obs < 0] + 2 * 
        pi
    obsLabel = (r.obs < gamma.fun(theta.obs))
    n.In = sum(obsLabel)
    n.Out = sum(!obsLabel)
    obs[obsLabel] = rnorm(n.In, mean = mu.in, sd = sd.in)
    obs[!obsLabel] = rnorm(n.Out, mean = mu.out, sd = sd.out)
    return(list(intensity = obs, theta.obs = theta.obs, r.obs = r.obs, 
        center = center, x = x.axis, y = y.axis))
}



# Example 1: R code only.  This uses the code from
set.seed(12345)
gamma.fun = ellipse(a = 0.35, b = 0.25)
obs = parnormobs(m = 100, mu.in = 4, mu.out = 1,sd.in = 1.5, sd.out = 1, design = 'J', gamma.fun)
rotate <- function(x) t(apply(x, 2, rev))  # rotate closewise by 90 degrees
image(rotate(obs$intensity), axes = FALSE, asp = 1, main = 'observation')
t1 = proc.time()
rbinary = BayesBD.norm(obs, ini.mean = 0.4, n.run = 5000, n.burn = 1000, J = 10, output.all = FALSE) 
t2 = proc.time()
t2-t1
theta.plot = seq(from = 0, to = 2*pi, length.out = 200)
plot.val = rbinary$gamma.hat(theta.plot)
x.plot = plot.val*cos(theta.plot)+.5
y.plot = plot.val*sin(theta.plot)+.5
lines(x.plot, y.plot, lwd=2)



# Example 2: c++ functions mhstep and unisliceL used for MCMC updating are called # within an R loop
set.seed(12345)
gamma.fun = ellipse(a = 0.35, b = 0.25)
obs = parnormobs(m = 100, mu.in = 4, mu.out = 1,sd.in = 1.5, sd.out = 1, design = 'J', gamma.fun)
rotate <- function(x) t(apply(x, 2, rev))  # rotate closewise by 90 degrees
image(rotate(obs$intensity), axes = FALSE, asp = 1, main = 'observation')
t1 = proc.time()
ini.mean = 0.4
n.run = 5000
n.burn = 1000
J = 10

     mu.fun <- function(theta) theta * 0 + ini.mean
    mu = c(mu.fun(obs$theta.obs))
    L = 2 * J + 1
    alpha.tau = 500
    beta.tau = 1
    alpha.lambda = 2
    beta.lambda = 1
    obs$demean = obs$r.obs - mu
    tmp.mat = sapply(1:L, function(k) eigen.fun(k)(c(obs$theta.obs)))
    an.smp = matrix(NA, L, n.run)
    par.smp = matrix(NA, 4, n.run)
    tau.smp = rep(NA, n.run)
    lambda.smp = rep(NA, n.run)
    an.ini = rep(0, L)
	n.all = length(obs$intensity)
    in.ini = (obs$r.obs < mu)
    m0 = mean(obs$intensity)	
    v0 = 1/var(as.vector(obs$intensity))
    m1.ini = sum(in.ini * obs$intensity)/sum(in.ini)
    m2.ini = sum((!in.ini) * obs$intensity)/sum(!in.ini)
    s1.ini = sd(as.vector(obs$intensity)[as.vector(in.ini)==TRUE])
    s2.ini = sd(as.vector(obs$intensity)[as.vector(in.ini)==FALSE])
    tau.ini = 500
    lambda.ini = 1
    cn.ini = sapply(0:J, function(ith) 2 * pi * exp(-2 * lambda.ini) * 
        besselI(2 * lambda.ini, ith))
    eigen.cn.ini = rep(cn.ini, each = 2)[-1]
    diff.ini = obs$demean - c(tmp.mat %*% an.ini)
    tmp = (diff.ini < 0)
    n.in <- sum(tmp)
    alpha1.ini = -log(s1.ini) 
	alpha2.ini = - log(s2.ini)
    beta.ini = -((2*((s1.ini)^2))^(-1))*sum(in.ini * ((obs$intensity-m1.ini)^2))-((2*((s2.ini)^2))^(-1))*sum((!in.ini) * ((obs$intensity-m2.ini)^2))
    mh.step <- function(k, an, alpha1,alpha2, beta, eigen.cn, tau,n.in,m1, m2, s1, s2) {
	  ret = list(an = an,n.in = n.in, beta = beta)
        eigen.cn.ini = eigen.cn
        an.old = matrix(an,L,1)
	  an.new.k = rnorm(1,an.old[k],.1)
	  an.new = an.old
	  an.new[k,1] = an.new.k
	  lL.old = n.in * alpha1-n.in*alpha2 + beta - t(an.old)%*%solve(diag(eigen.cn.ini))%*%an.old*tau.ini/2 
	  r.mat = c(tmp.mat %*% an.new + mu)
        tmp <- (obs$r.obs <= r.mat)
        n.in.new <- sum(tmp)
	  beta.ini = -((2*((s1)^2))^(-1))*sum(tmp * ((obs$intensity-m1)^2))-((2*((s2)^2))^(-1))*sum((!tmp) * ((obs$intensity-m2)^2))
	  lL.new = n.in.new * alpha1-n.in.new*alpha2 + beta.ini - t(an.new)%*%solve(diag(eigen.cn.ini))%*%an.new*tau.ini/2
        r = lL.new - lL.old + dnorm(an.new.k, an.old[k,1],.1) - dnorm(an.old[k,1],an.new.k ,.1)
        R <- min(exp(r), 1)
        if(runif(1) <= R) {
       	ret = list(an = an.new,n.in = n.in.new, beta = beta.ini)
        } 
	  return(ret)
    }

    logL.lambda = function(tau, an) {
        ret = function(lambda) {
            cn = sapply(0:J, function(ith) 2 * pi * exp(-2 * 
                lambda) * besselI(2 * lambda, ith))
            eigen.cn = rep(cn, each = 2)[-1]
            ret2 = -1/2 * (sum(log(eigen.cn)) + tau * sum(an^2/eigen.cn)) + 
                (alpha.lambda - 1) * log(lambda) - beta.lambda * 
                lambda
            return(ret2)
        }
        return(ret)
    }
    start <- proc.time()
    for (ith in 1:n.run) {
	k=1
        for (k in 1:L) {
          		an.n.new = mh.step(k,an.ini, alpha1.ini,alpha2.ini, beta.ini, eigen.cn.ini, tau.ini,n.in, m1.ini, m2.ini, s1.ini, s2.ini)
			n.in = an.n.new$n.in
			an.ini = an.n.new$an
			beta.ini = an.n.new$beta
	        }
	  a.star = alpha.tau + L/2
        b.star = beta.tau + sum(an.ini^2/eigen.cn.ini)/2
        tau.ini = rgamma(1, shape = a.star, rate = b.star)
        r.mat = c(tmp.mat %*% an.ini + mu)
        tmp <- (obs$r.obs <= r.mat)
        n.in <- sum(tmp)
        n.out = length(r.mat) - n.in
	  mean.in = ifelse(sum(tmp)==0,0,sum(tmp*obs$intensity)/n.in)
	  mean.out = ifelse(sum(!tmp)==0,0,sum((!tmp)*obs$intensity)/n.out)
        m1.0 = (n.in/(n.in+1))*mean.in + (1/(n.in+1))*m0
	  m2.0 = (n.out/(n.out+1))*mean.out + (1/(n.out+1))*m0
	  alph1.0 = 10+n.in/2
	  beta1.0 = .1+.5*sum(tmp*((obs$intensity-mean.in)^2)) + (n.in/(1+n.in))*(.5*(mean.in - m0)^2)
        alph2.0 = 10+n.out/2
	  beta2.0 = .11+.5*sum((!tmp)*((obs$intensity-mean.out)^2)) + (n.out/(1+n.out))*(.5*(mean.out - m0)^2)
	  x3 = 1/rgamma(1,shape = alph1.0,rate = beta1.0)
	  x4 = 1/rgamma(1,shape = alph2.0,rate = beta2.0)	  
	  s1.ini = x3^.5
	  s2.ini = x4^.5
	  x1 = rnorm(1,m1.0,sd = s1.ini/sqrt(n.in+1))
        x2 = rnorm(1,m2.0,sd = s2.ini/sqrt(n.out+1))
        m1.ini = x1
	  m2.ini = x2
        alpha1.ini = -log(s1.ini) 
	  alpha2.ini = - log(s2.ini)
        beta.ini = -((2*((s1.ini)^2))^(-1))*sum(tmp * ((obs$intensity-m1.ini)^2))-((2*((s2.ini)^2))^(-1))*sum((!tmp) * ((obs$intensity-m2.ini)^2))
        lambda.ini = uni.slice(lambda.ini, g = logL.lambda(tau = tau.ini, 
            an = an.ini), lower = 0, upper = 100)
        an.smp[, ith] = an.ini
        par.smp[, ith] = c(m1.ini,m2.ini,s1.ini,s2.ini)
        lambda.smp[ith] = lambda.ini
        tau.smp[ith] = tau.ini
        if (ith%%floor(n.run/100) == 1) {
            duration = proc.time() - start
           # cat(ith, "th iteration:", "ETA:", duration[3]/ith * 
            #    (n.run - ith), "\n")
        }
    }
    Total.Time = proc.time() - start
    an.MC = apply(an.smp[, n.burn:n.run], 1, mean)
    gamma.MC <- function(theta.arg) {
        c(sapply(1:L, function(k) eigen.fun(k)(theta.arg)) %*% 
            an.MC + mu.fun(theta.arg))
    }


t2 = proc.time()
t2-t1
theta.plot = seq(from = 0, to = 2*pi, length.out = 200)
plot.val = gamma.MC(theta.plot)
x.plot = plot.val*cos(theta.plot)+.5
y.plot = plot.val*sin(theta.plot)+.5
lines(x.plot, y.plot, lwd=2)


# Example 3: c++ only.  BayesBDnormal is used to run the entire sampling process within c++.

set.seed(12345)
gamma.fun = ellipse(a = 0.35, b = 0.25)
obs = parnormobs(m = 100, mu.in = 4, mu.out = 1,sd.in = 1.5, sd.out = 1, design = 'J', gamma.fun)
rotate <- function(x) t(apply(x, 2, rev))  # rotate closewise by 90 degrees
image(rotate(obs$intensity), axes = FALSE, asp = 1, main = 'observation')
t1 = proc.time()
cppsamp = BayesBDnormal(obs, .4, 4000, 1000, 10)
cppsamp
t2 = proc.time()
t2-t1
x = cppsamp$esttheta*cos(cppsamp$thetaplot)+.5
y = cppsamp$esttheta*sin(cppsamp$thetaplot) +.5
lines(x,y, lty = 2, lwd = 3)

# Runtime results: on an Intel Core i7-4790K CPU @ 4.00 GHz with 16 GB RAM running RGui 64-bit on Windows 10
#                       user      system    elapsed
#   c++ only            114.28   60.67  175.26    
#   c++ within R loop   60.99    0.29   61.50  
#   Only R              67.82    0.05   68.01 

