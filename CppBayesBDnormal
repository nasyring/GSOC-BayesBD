##########################################################################################
#  Author: Nicholas Syring
#  Title: BayesBD
#  Contact: nasyring@ncsu.edu; GitHub
##########################################################################################  	

# Requirements:
#               1. The libraries below.
#               2. A c++ compiler.
#               3. RTools.
#               4. R 3.2+ recommended.



# Directions:
#		1.  Make sure you meet the requirements above.
#		2.  Load the libraries below.
#		3.  Load the functions into your R session: BayesBD.norm, mhstep,
#		    unisliceL, eigenfun, BayesBDnorm, and parnormobs.
#		4.  Run the examples at the end of the code.  There are three examples
#		    comparing the runtime of R code, c++ within and R loop, and pure c++.
#               Each code can be run using either slice or Metropolis-Hastings sampling
#		    for the updates to eigenfunction coefficients.



# Required libraries.  

library(BayesBD)
library(Rcpp)
library(RcppArmadillo)
library(inline)

# This is an edited version of BayesBD.binary, a function appearing in the BayesBD
# library.  This function produces posterior samples for data from Gaussian images.  

BayesBD.norm = function (obs, ini.mean, n.run = 10000, n.burn = 1000, 
    J = 10, output.all = FALSE) 
{
    mu.fun <- function(theta) theta * 0 + ini.mean
    mu = c(mu.fun(obs$theta.obs))
    L = 2 * J + 1
    alpha.tau = 500
    beta.tau = 1
    alpha.lambda = 2
    beta.lambda = 1
    obs$demean = obs$r.obs - mu
    tmp.mat = sapply(1:L, function(k) eigen.fun(k)(c(obs$theta.obs)))
    an.smp = matrix(NA, L, n.run)
    par.smp = matrix(NA, 4, n.run)
    tau.smp = rep(NA, n.run)
    lambda.smp = rep(NA, n.run)
    an.ini = rep(0, L)
	n.all = length(obs$intensity)
    in.ini = (obs$r.obs < mu)
    m0 = mean(obs$intensity)	
    v0 = 1/var(as.vector(obs$intensity))
    m1.ini = sum(in.ini * obs$intensity)/sum(in.ini)
    m2.ini = sum((!in.ini) * obs$intensity)/sum(!in.ini)
    s1.ini = sd(as.vector(obs$intensity)[as.vector(in.ini)==TRUE])
    s2.ini = sd(as.vector(obs$intensity)[as.vector(in.ini)==FALSE])
    tau.ini = 500
    lambda.ini = 1
    cn.ini = sapply(0:J, function(ith) 2 * pi * exp(-2 * lambda.ini) * 
        besselI(2 * lambda.ini, ith))
    eigen.cn.ini = rep(cn.ini, each = 2)[-1]
    diff.ini = obs$demean - c(tmp.mat %*% an.ini)
    tmp = (diff.ini < 0)
    n.in <- sum(tmp)
    alpha1.ini = -log(s1.ini) 
    alpha2.ini = - log(s2.ini)
    beta.ini = -((2*((s1.ini)^2))^(-1))*sum(in.ini * ((obs$intensity-m1.ini)^2))-((2*((s2.ini)^2))^(-1))*sum((!in.ini) * ((obs$intensity-m2.ini)^2))
    mh.step <- function(k, an, alpha1,alpha2, beta, tmp.mat, eigen.cn, tau,n.in,m1, m2, s1, s2) {
	  ret = list(an = an,n.in = n.in, beta = beta)
        eigen.cn.ini = eigen.cn
        an.old = matrix(an,L,1)
	  an.new.k = rnorm(1,an.old[k],.05)
	  an.new = an.old
	  an.new[k,1] = an.new.k
	  lL.old = n.in * alpha1-n.in*alpha2 + beta - t(an.old)%*%diag(1/eigen.cn.ini)%*%an.old*tau.ini/2 
	  r.mat = c(tmp.mat %*% an.new + mu)
        tmp <- (obs$r.obs <= r.mat)
        n.in.new <- sum(tmp)
	  beta.ini = -((2*((s1)^2))^(-1))*sum(tmp * ((obs$intensity-m1)^2))-((2*((s2)^2))^(-1))*sum((!tmp) * ((obs$intensity-m2)^2))
	  lL.new = n.in.new * alpha1-n.in.new*alpha2 + beta.ini - t(an.new)%*%diag(1/eigen.cn.ini)%*%an.new*tau.ini/2
        r = lL.new - lL.old + dnorm(an.new.k, an.old[k,1],.05) - dnorm(an.old[k,1],an.new.k ,.05)
        R <- min(exp(r), 1)
        if(runif(1) <= R) {
       	ret = list(an = an.new,n.in = n.in.new, beta = beta.ini)
        } 
	  return(ret)
    }
    logL.anini <- function(k, tmpmat, an, mu, demean, intensityobs, mu1, mu2, sd1, sd2, tau, eigencn){
		ret = function(t){
			annew = an
			annew[k] = t
			rmat = tmpmat%*%annew+mu
			tmp = ifelse(as.vector(demean) < rmat, 1, 0)
			ninnew = sum(tmp)
			sdcomp = -sum(ifelse(tmp == 1, ((as.vector(intensityobs) - mu1)^2)/(2*sd1^2), ((as.vector(intensityobs) - mu2)^2)/(2*sd2^2)))
			ret2 = ninnew * (-log(sd1))-ninnew*(-log(sd2)) + sdcomp - t(annew)%*%diag(1.0/eigencn)%*%annew*tau/2
			attr(ret2, "nin") = ninnew
			attr(ret2, "sdcomp") = sdcomp
			return(ret2)
		}
		return(ret)	 
    }
    logL.lambda = function(tau, an) {
        ret = function(lambda) {
            cn = sapply(0:J, function(ith) 2 * pi * exp(-2 * 
                lambda) * besselI(2 * lambda, ith))
            eigen.cn = rep(cn, each = 2)[-1]
            ret2 = -1/2 * (sum(log(eigen.cn)) + tau * sum(an^2/eigen.cn)) + 
                (alpha.lambda - 1) * log(lambda) - beta.lambda * 
                lambda
            return(ret2)
        }
        return(ret)
    }
    for (ith in 1:n.run) {
        for (k in 1:L) {
			# use next four lines for slice sampling
          		#an.n.new = uni.slice(an.ini[k], g = logL.anini(k, tmp.mat, an.ini, mu, obs$r.obs, obs$intensity, m1.ini, m2.ini, s1.ini, s2.ini, tau.ini, eigen.cn.ini), lower = -100, upper = 100)
			#n.in = attr(an.n.new, "ninnew")
			#an.ini[k] = an.n.new
			#beta.ini = attr(an.n.new, "sdcomp")
			# alternatively to the above four lines, use next four lines for MH sampling
			an.n.new = mh.step(k,an.ini, alpha1.ini,alpha2.ini, beta.ini,tmp.mat, eigen.cn.ini, tau.ini,n.in, m1.ini, m2.ini, s1.ini, s2.ini)
			n.in = an.n.new$n.in
			an.ini = an.n.new$an
			beta.ini = an.n.new$beta
	        }
	  a.star = lambda.ini + L/2
        b.star = beta.tau + sum(an.ini^2/eigen.cn.ini)/2
        tau.ini = rgamma(1, shape = a.star, rate = b.star)
        r.mat = c(tmp.mat %*% an.ini + mu)
        tmp <- (obs$r.obs <= r.mat)
        n.in <- sum(tmp)
        n.out = length(r.mat) - n.in
	  mean.in = ifelse(sum(tmp)==0,0,sum(tmp*obs$intensity)/n.in)
	  mean.out = ifelse(sum(!tmp)==0,0,sum((!tmp)*obs$intensity)/n.out)
        m1.0 = (n.in/(n.in+1))*mean.in + (1/(n.in+1))*m0
	  m2.0 = (n.out/(n.out+1))*mean.out + (1/(n.out+1))*m0
	  alph1.0 = 10+n.in/2
	  beta1.0 = .1+.5*sum(tmp*((obs$intensity-mean.in)^2)) + (n.in/(1+n.in))*(.5*(mean.in - m0)^2)
        alph2.0 = 10+n.out/2
	  beta2.0 = .11+.5*sum((!tmp)*((obs$intensity-mean.out)^2)) + (n.out/(1+n.out))*(.5*(mean.out - m0)^2)
	  x3 = 1/rgamma(1,shape = alph1.0,rate = beta1.0)
	  x4 = 1/rgamma(1,shape = alph2.0,rate = beta2.0)	  
	  s1.ini = x3^.5
	  s2.ini = x4^.5
	  x1 = rnorm(1,m1.0,sd = s1.ini/sqrt(n.in+1))
        x2 = rnorm(1,m2.0,sd = s2.ini/sqrt(n.out+1))
        m1.ini = x1
	  m2.ini = x2
        alpha1.ini = -log(s1.ini) 
	  alpha2.ini = - log(s2.ini)
        beta.ini = -((2*((s1.ini)^2))^(-1))*sum(tmp * ((obs$intensity-m1.ini)^2))-((2*((s2.ini)^2))^(-1))*sum((!tmp) * ((obs$intensity-m2.ini)^2))
        lambda.ini = uni.slice(lambda.ini, g = logL.lambda(tau = tau.ini, 
            an = an.ini), lower = 0, upper = 100)
        an.smp[, ith] = an.ini
        par.smp[, ith] = c(m1.ini,m2.ini,s1.ini,s2.ini)
        lambda.smp[ith] = lambda.ini
        tau.smp[ith] = tau.ini
          }
       an.MC = apply(an.smp[, n.burn:n.run], 1, mean)
    gamma.MC <- function(theta.arg) {
        c(sapply(1:L, function(k) eigen.fun(k)(theta.arg)) %*% 
            an.MC + mu.fun(theta.arg))
    }
    result = list(gamma.hat = gamma.MC)
    if (output.all) {
	
plotStuff = function(theta){
	Len = n.run - n.burn
	sum_coords = 0
	var = 0
	u_i = matrix(0,Len,1)
	for(i in 1:Len){
		coords = sapply(1:L, function(k) eigen.fun(k)(theta)) %*% an.smp[, n.burn+i] + mu.fun(theta)
		sum_coords = sum_coords + coords
	}
	mean = sum_coords/1000
	for(i in 1:1000){
		coords = sapply(1:L, function(k) eigen.fun(k)(theta)) %*% an.smp[, n.burn+i] + mu.fun(theta)
		var = var + (coords - mean)^2
	}
	var = var / 1000
	sd = var^.5
	for(i in 1:1000){
		coords = sapply(1:L, function(k) eigen.fun(k)(theta)) %*% an.smp[, n.burn+i] + mu.fun(theta)
		u_i[i,1] = (coords - mean)/sd
	}
	L0 = sort(u_i)[.95*length(u_i)]
	lower = mean - L0*sd
	upper = mean + L0*sd
	x1 = mean * cos(theta)
	y1 = mean * sin(theta)
	lx1 = lower * cos(theta)
	ly1 = lower * sin(theta)
	ux1 = upper * cos(theta)
	uy1 = upper * sin(theta)
return(list(mean = mean, x = x1, y = y1, lx = lx1, ly = ly1, ux = ux1, uy = uy1))
}


        result = list(plotStuff=plotStuff,an.smp = an.smp, par.smp = par.smp, tau.smp = tau.smp, 
            lambda.smp = lambda.smp, gamma.hat = gamma.MC)
    }
    return(result)
}


# This is a c++ function which can be used with the Rcpp package to produce posterior
# samples of the 'z' parameter; see Step 2 and its modifications in Section 5: Sampling 
# Algorithms in Li and Ghosal 2015 for details.  This function is used by another c++
# function, BayesBDnorm, below to loop the posterior sampling process. This version
# does MCMC sampling using Metropolis Hastings within Gibbs


cppFunction(depends = "RcppArmadillo",'Rcpp::List mhstep(int & k, double & gxZ, arma::mat & tmpmat, arma::colvec & mu,arma::colvec & intensityobs,arma::colvec & demean, arma::colvec & an, double & alpha1, double & alpha2, arma::colvec & eigencn, double & tau, int & nin, double & mu1, double & mu2, double & sd1, double & sd2){
RNGScope scope;
	int s = mu.n_rows;
	NumericVector ank;
	NumericVector anok; anok[0] = an(k);
	arma::colvec tmp = arma::colvec(s); tmp.fill(0.0); 
	arma::colvec lLnew = arma::colvec(1); 
	arma::colvec rmat = arma::colvec(s); 
	arma::colvec ninnew = arma::colvec(1); 
	arma::colvec sdcomp = arma::colvec(1); 
	arma::colvec std_sum = arma::colvec(1); 
	arma::colvec r = arma::colvec(1); 
	arma::colvec uu = arma::colvec(1); 
	ank = rnorm(1, an(k), 0.05); 
	arma::colvec annew; annew = an; annew(k) = ank[0]; 
	rmat = tmpmat*annew + mu;
	for(int i = 0; i<s; i++){
		if(demean(i)<rmat(i)){
			tmp(i) = 1;}
	}
	sdcomp = (intensityobs - (tmp*mu1 + (1.0-tmp)*mu2))/(tmp*sd1 + (1.0-tmp)*sd2);
	std_sum = -sdcomp.t()*sdcomp*0.5;
	ninnew(0) = sum(tmp);
	lLnew = ninnew * alpha1-ninnew*alpha2 + std_sum - annew.t()*(annew/eigencn)*tau*0.5;
	r = dnorm(ank, anok[0],.05) - dnorm(anok,ank[0],.05);
	r = r + lLnew - gxZ;
      r(0) = fmin(exp(r(0)), 1.0);
	uu = runif(1);
      if(uu(0) <= r(0)) {
      	return(Rcpp::List::create(Rcpp::Named("x1") = ank[0], Rcpp::Named("nin") = ninnew, Rcpp::Named("gxZ") = lLnew));
      }else{ 
		return(Rcpp::List::create(Rcpp::Named("x1") = anok[0], Rcpp::Named("nin") = nin, Rcpp::Named("gxZ") = gxZ, Rcpp::Named("lnew") = lLnew, Rcpp::Named("new") = ank[0], Rcpp::Named("ninnew") = ninnew, Rcpp::Named("std_sum") = std_sum));
	}
}') 


cppFunction(depends = "RcppArmadillo",'Rcpp::List unisliceZ(int & k, arma::colvec & gxZ, arma::mat & tmpmat, arma::colvec & mu,arma::colvec & intensityobs,arma::colvec & demean, arma::colvec & an, arma::colvec & alpha1, arma::colvec & alpha2, arma::colvec & eigencn, arma::colvec & tau, arma::colvec & nin, arma::colvec & mu1, arma::colvec & mu2, arma::colvec & sd1, arma::colvec & sd2){
RNGScope scope;
Rcpp::NumericVector rndsmp = Rcpp::NumericVector( Rcpp::Dimension(1)); rndsmp = rexp(1);
arma::colvec logy = arma::colvec(1); logy(0) = gxZ(0) - rndsmp[0];
rndsmp = runif(1, 0, 1.0);
arma::colvec L = arma::colvec(1); L(0) = an(k) - rndsmp[0];
arma::colvec R = arma::colvec(1); R(0) = L(0) + 1.0;
arma::colvec x1 = arma::colvec(1);x1(0)=0.0;
arma::colvec g = arma::colvec(1); g(0)=0.0;
arma::colvec gxF = arma::colvec(1); gxF(0)=0.0;
arma::colvec count = arma::colvec(1); count(0)=-1.0;
int s = mu.n_rows;
arma::colvec tmp = arma::colvec(s); 
arma::colvec rmat = arma::colvec(s); 
arma::colvec ninnew = arma::colvec(1); 
arma::colvec sdcomp = arma::colvec(1); 
arma::colvec std_sum = arma::colvec(1);  
arma::colvec annew; annew = an; 

bool res1 = TRUE;
bool res2 = FALSE;
bool res3 = FALSE;

while( res1 ){
            count = count+1.0;
		res1 =  count(0) < 200.0 ;
	      res2 = L(0)<=-10.0;
            if (res2){ 
			L(0) = L(0)+1.0;
			res1= FALSE;}
		else {
			annew(k) = L(0);
			rmat = tmpmat*annew + mu;
			for(int i = 0; i<s; i++){
				if(demean(i)<rmat(i)){
					tmp(i) = 1;}
				else{tmp(i)=0;}
			}			
			sdcomp = (intensityobs - (tmp*mu1(0) + (1.0-tmp)*mu2(0)))/(tmp*sd1(0) + (1.0-tmp)*sd2(0));
			std_sum = -sdcomp.t()*sdcomp/2.0;
			ninnew(0) = sum(tmp);
			g = ninnew * alpha1-ninnew*alpha2 + std_sum - annew.t()*diagmat(1.0/eigencn)*annew*tau/2;
			res3 = g(0) <= logy(0);
		}
            if (res3){ 
			L(0) = L(0)+1.0;
			res1=FALSE;}
            L(0) = L(0) - 1.0;
            }
		count = -1.0;
		res1 = TRUE;res2 = FALSE;res3 = FALSE;
       while( res1 ){
            count = count+1.0;
		res1 =  count(0) < 200.0 ;
		res2 = R(0)>=10.0;
            if (res2){ 
			R(0) = R(0)-1.0;
			res1= FALSE;}
		else {
			annew(k) = R(0);
			rmat = tmpmat*annew + mu;
			for(int i = 0; i<s; i++){
				if(demean(i)<rmat(i)){
					tmp(i) = 1;}else{tmp(i)=0;}
			}
			sdcomp = (intensityobs - (tmp*mu1(0) + (1.0-tmp)*mu2(0)))/(tmp*sd1(0) + (1.0-tmp)*sd2(0));
			std_sum = -sdcomp.t()*sdcomp/2.0;
			ninnew(0) = sum(tmp);
			g = ninnew * alpha1-ninnew*alpha2 + std_sum - annew.t()*diagmat(1.0/eigencn)*annew*tau/2;
			res3 = g(0) <= logy(0);
		}
            if (res3){ 
			R(0) = R(0)-1.0;
			res1=FALSE;}
            R(0) = R(0) + 1.0;
            }
		
	res1 = L(0)<=-10.0;
    if (res1) {
        L(0) = -10.0;
    }
	res1 = R(0)>10.0;
    if (res1) {
        R(0) = 10.0;
    }
	count = -1.0;
	res1 = TRUE;res2 = FALSE;res3 = FALSE;
    while(res1) {
		count=count+1;
		if (count(0) > 200.0){
		res1 = FALSE;
		gxF = gxZ;
		x1 = an(k);}
		else{
       	if (res2){ 
			gxF = g;
			res1 = FALSE;
			}
		else {
			x1 = runif(1, L(0), R(0));
			annew(k) = x1(0);
			rmat = tmpmat*annew + mu;
			for(int i = 0; i<s; i++){
				if(demean(i)<rmat(i)){
					tmp(i) = 1;}else{tmp(i)=0;}
			}
			sdcomp = (intensityobs - (tmp*mu1(0) + (1.0-tmp)*mu2(0)))/(tmp*sd1(0) + (1.0-tmp)*sd2(0));
			std_sum = -sdcomp.t()*sdcomp/2.0;
			ninnew(0) = sum(tmp);
			g = ninnew * alpha1-ninnew*alpha2 + std_sum - annew.t()*diagmat(1.0/eigencn)*annew*tau/2;
			res3 = (x1(0) > an(k));
		}
	  	  	res2 = (g(0) >= logy(0));
        if (res3) {
            R(0) = x1(0);
        }
        else {
            L(0) = x1(0);
        }}
    }  
 	return Rcpp::List::create(Rcpp::Named("x1") = x1,Rcpp::Named("nin") = ninnew, Rcpp::Named("gxZ") = gxF, Rcpp::Named("count") = count);
}')


# This is a c++ function which can be used with the Rcpp package to produce posterior
# samples of the 'a' parameter; see Step 5 in Section 5: Sampling Algorithms in Li and Ghosal 2015 for 
# details.  This function is used by another c++ function, BayesBDnorm, below to loop
# the posterior sampling process.

cppFunction(depends = "RcppArmadillo",'Rcpp::List unisliceL(arma::colvec & x0, arma::colvec & gx0, int & i_J, arma::colvec & tauini, arma::colvec & anini, int & alphalambda, int & betalambda, arma::colvec & lambdaini){
RNGScope scope;
Rcpp::Function besselI("besselI");
Rcpp::NumericVector rndsmp = Rcpp::NumericVector( Rcpp::Dimension(1)); rndsmp = rexp(1);
arma::colvec logy = arma::colvec(1); logy(0) = gx0(0) - rndsmp[0];
rndsmp = runif(1, 0, 1.0);
arma::colvec L = arma::colvec(1); L(0) = lambdaini(0) - rndsmp[0];
arma::colvec R = arma::colvec(1); R(0) = L(0) + 1.0;
arma::colvec x1 = arma::colvec(1);x1(0)=0.0;
arma::colvec g = arma::colvec(1); g(0)=0.0;
arma::colvec count = arma::colvec(1); count(0)=0.0;
arma::colvec interim = arma::colvec(1);interim(0) = 0.0;
arma::colvec cnini = arma::colvec(i_J+1);
arma::colvec eigencnini = arma::colvec(2*i_J+1);
arma::colvec calc1 = arma::colvec(1);calc1(0) = 0.0;
bool res1 = TRUE;
bool res2 = FALSE;
bool res3 = FALSE;

while( res1 ){
		interim(0)=0.0;
            count = count+1.0;
		res1 =  count(0) < 100.0 ;
	      res2 = L(0)<=0.0;
            if (res2){ 
			L(0) = L(0)+1.0;
			res1= FALSE;}
		else {
			calc1 = 2*M_PI*exp(-2*L);
			for(int i=0; i<(i_J+1); i++){
				cnini(i) = calc1(0)*Rcpp::as<double>(besselI(2*L,i));
			}
			eigencnini(0) = cnini(0);
			for(int i=1; i<(i_J+1); i++){
				eigencnini(2*i-1) = cnini(i);
				eigencnini(2*i) = cnini(i);
			} 
			interim = anini.t()*(anini / eigencnini);
			g = -0.5 * (sum(log(eigencnini)) + tauini * interim) + (alphalambda - 1) * log(L) - betalambda * L;
			res3 = g(0) <= logy(0);
		}
            if (res3){ 
			L(0) = L(0)+1.0;
			res1=FALSE;}
            L(0) = L(0) - 1.0;
            }
		count = 0.0;
		res1 = TRUE;res2 = FALSE;res3 = FALSE;
       while( res1 ){
		interim(0)=0.0;
            count = count+1.0;
		res1 =  count(0) < 100.0 ;
		res2 = R(0)>=500.0;
            if (res2){ 
			R(0) = R(0)-1.0;
			res1= FALSE;}
		else {
			calc1 = 2*M_PI*exp(-2*R);
			for(int i=0; i<(i_J+1); i++){
				cnini(i) = calc1(0)*Rcpp::as<double>(besselI(2*R,i));
			}
			eigencnini(0) = cnini(0);
			for(int i=1; i<(i_J+1); i++){
				eigencnini(2*i-1) = cnini(i);
				eigencnini(2*i) = cnini(i);
			}
			interim = anini.t()*(anini / eigencnini);
			g = -0.5 * (sum(log(eigencnini)) + tauini * interim) + (alphalambda - 1) * log(R) - betalambda * R;
			res3 = (g(0) <= logy(0));
		}
            if (res3){ 
			R(0) = R(0)-1.0;
			res1=FALSE;}
            R(0) = R(0) + 1.0;
            }
		
	res1 = L(0)<=0.0;
    if (res1) {
        L(0) = 0.0;
    }
	res1 = R(0)>500.0;
    if (res1) {
        R(0) = 500.0;
    }
	count = 0.0;
	res1 = TRUE;res2 = FALSE;res3 = FALSE;
    while(res1) {
		interim(0)=0.0;
		count=count+1;
		res1 =  count(0) < 200.0  ;
       	if (res2){ 
			res1 = FALSE;
			}
		else {
			x1 = runif(1, L(0), R(0));
			calc1 = 2*M_PI*exp(-2*x1);
			for(int i=0; i<(i_J+1); i++){
				cnini(i) = calc1(0)*Rcpp::as<double>(besselI(2*x1,i));
			}
			eigencnini(0) = cnini(0);
			for(int i=1; i<(i_J+1); i++){
				eigencnini(2*i-1) = cnini(i);
				eigencnini(2*i) = cnini(i);
			}
			interim = anini.t()*(anini / eigencnini);
			g = -0.5 * (sum(log(eigencnini)) + tauini * interim) + (alphalambda - 1) * log(x1) - betalambda * x1;
			res3 = (x1(0) > x0(0));
		}
	  	  	res2 = (g(0) >= logy(0));
        if (res3) {
            R(0) = x1(0);
        }
        else {
            L(0) = x1(0);
        }
    }  
 	//return Rcpp::List::create(Rcpp::Named("x1") = x1, Rcpp::Named("count") = count);
 	return Rcpp::List::create(Rcpp::Named("x1") = x1, Rcpp::Named("count") = count, Rcpp::Named("eigencnini") = eigencnini);
}')


# This c++ function computes the nth eigenfunction of the SEP kernel.  It is used by
# BayesBDnormal below.


cppFunction('double eigenfun(int & n, double & x) { 
	int k1 = n%2;
    	double k2 = (n - k1)/2;
	double ret = 0;
   	if (n == 1) {
       		 ret = 1/sqrt(2 * M_PI) + 0 * x;
    	}
    	if (n > 1) {
        	if (k1 == 0) {
            		 ret = 1/sqrt(M_PI) * cos(k2 * x);
        	}
       		if (k1 == 1) {
            		 ret = 1/sqrt(M_PI) * sin(k2 * x);
       		}
    }
    return ret;
}')

# This c++ function is a translation to c++ of the BayesBD.norm R function above.  It
# produces posterior samples of the boundary of a Gaussian image.  The output is a set of
# boundary values at 200 points, to be plotted on the image. 

cppFunction(depends = "RcppArmadillo",'Rcpp::List BayesBDnormal(SEXP obs, SEXP inimean, SEXP nrun, SEXP nburn, SEXP J) { 

// Including additional user-defined Rcpp functions
RNGScope scp;
Rcpp::Function eigenfun("eigenfun");
Rcpp::Function besselI("besselI");
//Rcpp::Function unisliceZ("unisliceZ"); /*use this for slice sampling and line below for MH sampling*/
//Rcpp::Function mhstep("mhstep");
Rcpp::Function unisliceL("unisliceL");

// Extracting the inputs
Rcpp::List 		      	obsL(obs);
arma::mat thetaobs 	 	= Rcpp::as<arma::mat>(obsL["theta.obs"]);
arma::colvec demean 	 	= Rcpp::as<arma::colvec>(obsL["r.obs"]);
arma::colvec intensityobs     = Rcpp::as<arma::colvec>(obsL["intensity"]);
int i_nrun 				= Rcpp::as<int>(nrun);
int i_nburn				= Rcpp::as<int>(nburn);
int i_J				= Rcpp::as<int>(J);
double d_inimean 			= Rcpp::as<double>(inimean);

// Declaring variables 
Rcpp::List temp2del;
Rcpp::List lambdalist;

int s					= thetaobs.size();
int L                  		= 2*i_J+1;
int betatau           		= 1;
int alphalambda      		= 2;
int betalambda       		= 1;
int nin = 0;
int nout = 0;


arma::colvec tmpmatk		= arma::colvec(s); tmpmatk.fill(0.0);
arma::colvec mu			= arma::colvec(s); mu.fill(d_inimean);
arma::colvec diffini          = demean - mu;
arma::colvec eigencnk   	= arma::colvec(1); eigencnk.fill(0.0);
arma::colvec ank   	      = arma::colvec(1); ank.fill(0.0); 
arma::colvec astar   	      = arma::colvec(1); astar(0)=0.0;
arma::colvec bstar   	      = arma::colvec(1); bstar(0)=0.0;
arma::colvec tauinirg   	= arma::colvec(1); tauinirg(0)=500.0;
arma::colvec mu0 		      = arma::colvec(1); mu0 = sum(intensityobs)/s;
arma::colvec sd0 		      = arma::colvec(1); sd0.fill(1000.0);
arma::colvec mu1 		      = arma::colvec(1); mu1(0) = mu0(0);
arma::colvec mu2 		      = arma::colvec(1); mu2(0) = mu0(0);
arma::colvec sd1 		      = arma::colvec(1); sd1(0) = sd0(0);
arma::colvec sd2 		      = arma::colvec(1); sd2(0) = sd0(0);
arma::colvec xbarin 		= arma::colvec(1); xbarin.fill(0.0);
arma::colvec xbarout 		= arma::colvec(1); xbarout.fill(0.0);
arma::colvec xinsum 		= arma::colvec(1); xinsum.fill(0.0);
arma::colvec xoutsum 		= arma::colvec(1); xoutsum.fill(0.0);
arma::colvec xinsumsq 		= arma::colvec(1); xinsumsq.fill(0.0);
arma::colvec xoutsumsq 		= arma::colvec(1); xoutsumsq.fill(0.0);
arma::colvec ssin 		= arma::colvec(1); ssin.fill(0.0);
arma::colvec ssout 		= arma::colvec(1); ssout.fill(0.0);
arma::colvec calc1 		= arma::colvec(1); calc1.fill(0.0);
arma::colvec std_sum 		= arma::colvec(1); std_sum.fill(0.0);
arma::colvec lambdaini 		= arma::colvec(1); lambdaini(0)=1.0;
arma::colvec anini 		= arma::colvec(L); anini.fill(0.0);
arma::colvec cnini            = arma::colvec(i_J+1); cnini.fill(0.0);
arma::colvec eigencnini       = arma::colvec(L); eigencnini.fill(0.0);
arma::colvec interim          = arma::colvec(1); interim.fill(0.0);
arma::colvec rmat             = arma::colvec(s); rmat.fill(0.0);
arma::colvec tmpp             = arma::colvec(s); tmpp.fill(0.0);
arma::colvec sdcomp           = arma::colvec(s); sdcomp.fill(0.0);
arma::colvec gx0              = arma::colvec(1); gx0.fill(0.0);
arma::colvec gxZ              = arma::colvec(1); gxZ.fill(0.0);
arma::colvec ansum		= arma::colvec(L); ansum.fill(0.0);
arma::mat tmpmat              = arma::mat(s,L); tmpmat.fill(0.0);


// Filling tmpmat with values for each of L eigenfunctions for each of s observations
for (int i=0; i<s; i++) {
	for(int j = 0; j<L;j++){
            tmpmat(i,j) = Rcpp::as<double>(eigenfun(j+1,thetaobs[i]));
	}
}


calc1 = 2.0*M_PI*exp(-2*lambdaini);
for(int i=0; i<(i_J+1); i++){
	cnini(i) = calc1(0)*Rcpp::as<double>(besselI(2.0*lambdaini,i));
}

eigencnini(0) = cnini(0);
for(int i=1; i<(i_J+1); i++){
	eigencnini(2*i-1) = cnini(i);
	eigencnini(2*i) = cnini(i);
} 

for(int i = 0; i<s; i++){
	if(diffini(i)<0){
		tmpp(i) = 1;
	}else{tmpp(i)=0;}
}

nin = sum(tmpp);
nout = s - nin;

mu1 = tmpp.t()*intensityobs/nin; mu2 = intensityobs.t()*(1.0-tmpp)/nout;
ssin = trans(intensityobs % tmpp - mu1(0)* tmpp)*(intensityobs % tmpp - mu1(0)* tmpp);
ssout = trans(intensityobs % (1.0-tmpp) - mu2(0)* (1.0-tmpp))*(intensityobs % (1.0-tmpp) - mu2(0)* (1.0-tmpp));
sd1 = pow(ssin/(nin-1), 0.5);
sd2 = pow(ssout/(nout-1), 0.5);

sdcomp = (intensityobs - (tmpp*mu1(0) + (1.0-tmpp)*mu2(0)))/(tmpp*sd1(0) + (1.0-tmpp)*sd2(0));
std_sum = -sdcomp.t()*sdcomp*0.5;
gxZ = nin * (-log(sd1(0)))-nin*(-log(sd2(0))) + std_sum - anini.t()*diagmat(1.0/eigencnini)*anini*tauinirg/2;


Rcpp::NumericVector thetaplot = Rcpp::NumericVector( Rcpp::Dimension(200));
for(int k = 0; k<200; k++){
 thetaplot[k] = 2.0*M_PI*(k*0.005); 
}
Rcpp::NumericVector estfunc = Rcpp::NumericVector( Rcpp::Dimension(1));
Rcpp::NumericVector esttheta = Rcpp::NumericVector( Rcpp::Dimension(200));
arma::colvec cc = arma::colvec(s);cc.fill(0.0);

/*
NumericVector ankk;
NumericVector anok; 
arma::colvec lLnew = arma::colvec(1); 
int ninnew = 0; 
arma::colvec r = arma::colvec(1); 
arma::colvec uu = arma::colvec(1);  
arma::colvec annew; 
*/
Rcpp::NumericVector rndsmp = Rcpp::NumericVector( Rcpp::Dimension(1)); 
arma::colvec logy = arma::colvec(1); 
arma::colvec LL = arma::colvec(1); 
arma::colvec R = arma::colvec(1); 
arma::colvec x1 = arma::colvec(1);
arma::colvec g = arma::colvec(1); 
arma::colvec gxF = arma::colvec(1); 
arma::colvec count = arma::colvec(1); 
int ninnew = 0; 
arma::colvec annew; 
bool res1 = TRUE;
bool res2 = FALSE;
bool res3 = FALSE;


	
//main loop
for(int i=0; i<(i_nrun+i_nburn); i++){
for(int k=0; k<L; k++){
	/*
	tmpp.fill(0.0);
	anok[0] = anini(k);
	annew = anini; 
	ankk = rnorm(1, anini(k), 0.05); 
	annew(k) = ankk[0];
	rmat = tmpmat*annew + mu;
	for(int i = 0; i<s; i++){
		if(demean(i)<rmat(i)){
			tmpp(i) = 1.0;}
	}
	sdcomp = (intensityobs - (tmpp*mu1 + (1.0-tmpp)*mu2))/(tmpp*sd1 + (1.0-tmpp)*sd2);
	std_sum = -sdcomp.t()*sdcomp*0.5;
	ninnew = sum(tmpp);
	lLnew = ninnew * (-log(sd1))-ninnew*(-log(sd2)) + std_sum - annew.t()*(annew/eigencnini)*tauinirg*0.5;
	r = dnorm(ankk, anok[0],.05) - dnorm(anok,ankk[0],.05);
	r = r + lLnew - gxZ;
      r(0) = fmin(exp(r(0)), 1.0);
	uu = runif(1);
      if(uu(0) <= r(0)) {
		anini(k) = ankk[0];
		nin = ninnew;
		gxZ = lLnew;
      }*/
rndsmp = rexp(1);
logy(0) = gxZ(0) - rndsmp[0];
rndsmp = runif(1, 0, 1.0);
LL(0) = anini(k) - rndsmp[0];
R(0) = LL(0) + 1.0;
x1(0)=0.0;
g(0)=0.0;
gxF(0)=0.0;
count(0)=-1.0;
ninnew = 0; 
annew = anini; 
res1 = TRUE;
res2 = FALSE;
res3 = FALSE;
tmpp.fill(0.0);

while( res1 ){
            count = count+1.0;
		res1 =  count(0) < 200.0 ;
	      res2 = LL(0)<=-10.0;
            if (res2){ 
			LL(0) = LL(0)+1.0;
			res1= FALSE;}
		else {
			annew(k) = LL(0);
			rmat = tmpmat*annew + mu;
			for(int i = 0; i<s; i++){
				if(demean(i)<rmat(i)){
					tmpp(i) = 1;}
				else{tmpp(i)=0;}
			}			
			sdcomp = (intensityobs - (tmpp*mu1(0) + (1.0-tmpp)*mu2(0)))/(tmpp*sd1(0) + (1.0-tmpp)*sd2(0));
			std_sum = -sdcomp.t()*sdcomp/2.0;
			ninnew = sum(tmpp);
			g = ninnew * (-log(sd1))-ninnew*(-log(sd2)) + std_sum - annew.t()*diagmat(1.0/eigencnini)*annew*tauinirg/2;
			res3 = g(0) <= logy(0);
		}
            if (res3){ 
			LL(0) = LL(0)+1.0;
			res1=FALSE;}
            LL(0) = LL(0) - 1.0;
            }
		count = -1.0;
		res1 = TRUE;res2 = FALSE;res3 = FALSE;
       while( res1 ){
            count = count+1.0;
		res1 =  count(0) < 200.0 ;
		res2 = R(0)>=10.0;
            if (res2){ 
			R(0) = R(0)-1.0;
			res1= FALSE;}
		else {
			annew(k) = R(0);
			rmat = tmpmat*annew + mu;
			for(int i = 0; i<s; i++){
				if(demean(i)<rmat(i)){
					tmpp(i) = 1;}else{tmpp(i)=0;}
			}
			sdcomp = (intensityobs - (tmpp*mu1(0) + (1.0-tmpp)*mu2(0)))/(tmpp*sd1(0) + (1.0-tmpp)*sd2(0));
			std_sum = -sdcomp.t()*sdcomp/2.0;
			ninnew = sum(tmpp);
			g = ninnew * (-log(sd1))-ninnew*(-log(sd2)) + std_sum - annew.t()*diagmat(1.0/eigencnini)*annew*tauinirg/2;
			res3 = g(0) <= logy(0);
		}
            if (res3){ 
			R(0) = R(0)-1.0;
			res1=FALSE;}
            R(0) = R(0) + 1.0;
            }
		
	res1 = LL(0)<=-10.0;
    if (res1) {
        LL(0) = -10.0;
    }
	res1 = R(0)>10.0;
    if (res1) {
        R(0) = 10.0;
    }
	count = -1.0;
	res1 = TRUE;res2 = FALSE;res3 = FALSE;
    while(res1) {
		count=count+1;
		if (count(0) > 200.0){
		res1 = FALSE;
		gxF = gxZ;
		x1 = anini(k);}
		else{
       	if (res2){ 
			gxF = g;
			res1 = FALSE;
			}
		else {
			x1 = runif(1, LL(0), R(0));
			annew(k) = x1(0);
			rmat = tmpmat*annew + mu;
			for(int i = 0; i<s; i++){
				if(demean(i)<rmat(i)){
					tmpp(i) = 1;}else{tmpp(i)=0;}
			}
			sdcomp = (intensityobs - (tmpp*mu1(0) + (1.0-tmpp)*mu2(0)))/(tmpp*sd1(0) + (1.0-tmpp)*sd2(0));
			std_sum = -sdcomp.t()*sdcomp/2.0;
			ninnew = sum(tmpp);
			g = ninnew * (-log(sd1))-ninnew*(-log(sd2)) + std_sum - annew.t()*diagmat(1.0/eigencnini)*annew*tauinirg/2;
			res3 = (x1(0) > anini(k));
		}
	  	  	res2 = (g(0) >= logy(0));
        if (res3) {
            R(0) = x1(0);
        }
        else {
            LL(0) = x1(0);
        }}
    }  
 	anini(k) = x1(0);
	nin = ninnew;
	gxZ = gxF;
		
		// use next line for MH sampling instead of slice sampling below it
		//temp2del = mhstep(k, gxZ, tmpmat, mu, intensityobs, demean, anini, -log(sd1(0)),-log(sd2(0)), eigencnini, tauinirg, nin, mu1, mu2, sd1, sd2);
		//temp2del = unisliceZ(k, gxZ, tmpmat, mu, intensityobs, demean, anini, -log(sd1(0)),-log(sd2(0)), eigencnini, tauinirg, nin, mu1, mu2, sd1, sd2);
		//anini(k) = Rcpp::as<double>(temp2del["x1"]);
		//nin = Rcpp::as<int>(temp2del["nin"]);
		//gxZ = Rcpp::as<arma::colvec>(temp2del["gxZ"]);
	}
astar = lambdaini + L/2;
interim = anini.t()*(anini / eigencnini);
bstar = betatau + interim*0.5;
tauinirg = rgamma(1,astar(0),bstar(0));
rmat = tmpmat*anini + mu;
for(int j = 0; j< s; j++){
	if(demean(j)<=rmat(j)){tmpp(j)=1.0;}
	else{tmpp(j)=0.0;}
}
nin = sum(tmpp); nout = s - nin;
xbarin = tmpp.t()*intensityobs/nin; xbarout = intensityobs.t()*(1.0-tmpp)/nout;
ssin = trans(intensityobs % tmpp - xbarin(0)* tmpp)*(intensityobs % tmpp - xbarin(0)* tmpp);
ssout = trans(intensityobs % (1.0-tmpp) - xbarout(0)* (1.0-tmpp))*(intensityobs % (1.0-tmpp) - xbarout(0)* (1.0-tmpp));
sd1 = pow(1/rgamma(1, 0.01 + nin*0.5, 1/(0.01+0.5*ssin(0) + (nin/(nin+1))*(pow(xbarin(0) - mu0(0),2.0)*0.5))),0.5);
sd2 = pow(1/rgamma(1, 0.01 + nout*0.5, 1/(0.01+0.5*ssout(0) + (nout/(nout+1))*(pow(xbarout(0) - mu0(0),2.0)*0.5))),0.5);
mu1 = rnorm(1,mu0(0)/(nin+1) + nin*xbarin(0)/(nin+1), sd1(0)/pow(nin+1.0,0.5));
mu2 = rnorm(1,mu0(0)/(nout+1) + nout*xbarout(0)/(nout+1), sd2(0)/pow(nout+1.0,0.5));
sdcomp = (intensityobs - (tmpp*mu1(0) + (1.0-tmpp)*mu2(0)))/(tmpp*sd1(0) + (1.0-tmpp)*sd2(0));
std_sum = -sdcomp.t()*sdcomp*0.5;
gx0 = -0.5 * (sum(log(eigencnini)) + tauinirg * interim) + (alphalambda - 1) * log(lambdaini) - betalambda * lambdaini;
lambdalist = unisliceL(lambdaini, gx0, i_J, tauinirg, anini,  alphalambda,  betalambda, lambdaini);
lambdaini = Rcpp::as<NumericVector>(lambdalist["x1"]);
eigencnini = Rcpp::as<arma::colvec>(lambdalist["eigencnini"]);
cc(i) = Rcpp::as<double>(lambdalist["count"]);
gxZ = nin * (-log(sd1(0)))-nin*(-log(sd2(0))) + std_sum - anini.t()*(anini / eigencnini)*tauinirg/2;

if(i > i_nburn){
ansum = ansum + anini;
}

}

ansum = ansum/i_nrun;
for(int k = 0; k<200; k++){
		estfunc[0]=0.0;
  		for(int j = 0; j<L; j++){
			estfunc[0] = estfunc[0] + Rcpp::as<double>(eigenfun(j+1,thetaplot[k]))*ansum(j)+(d_inimean/L);
		}
		esttheta[k] =estfunc[0]+esttheta[k];
}


return Rcpp::List::create(Rcpp::Named("count") = cc, Rcpp::Named("esttheta") = esttheta,Rcpp::Named("thetaplot") = thetaplot, Rcpp::Named("anini") = anini, Rcpp::Named("ansum") = ansum);

//return Rcpp::List::create(Rcpp::Named("count") = cc, Rcpp::Named("gxZ") = gxZ, Rcpp::Named("lambdaini") = lambdaini, Rcpp::Named("mu1") = mu1, Rcpp::Named("mu2") = mu2, Rcpp::Named("sd1") = sd1, Rcpp::Named("sd2") = sd2, Rcpp::Named("tauinirg") = tauinirg, Rcpp::Named("anini") = anini, Rcpp::Named("eigencnini") = eigencnini);
}')



# Examples: What follows are examples of using R code only, an R loop with c++ sampling,
# and c++ only to produce boundary estimates for binary images.  We set the seed before
# each example to use the same data, and we compute the runtime for comparison. 

# Load this function.  This will be used to suimulate image data.

parnormobs = function (m, mu.in, mu.out, sd.in, sd.out, design, gamma.fun) {
    center = c(0.5, 0.5)
    obs <- matrix(NA, m, m)
    if (design == "D") {
        x.axis = (col(obs) - 1)/m + 1/(2 * m)
        y.axis = (m - row(obs))/m + 1/(2 * m)
    }
    if (design == "J") {
        x.axis = (col(obs) - 1)/m + 1/(2 * m) + runif(m^2, min = -1/(2 * 
            m), max = 1/(2 * m))
        y.axis = (m - row(obs))/m + 1/(2 * m) + runif(m^2, min = -1/(2 * 
            m), max = 1/(2 * m))
    }
    r.obs = sqrt((x.axis - center[1])^2 + (y.axis - center[2])^2)
    theta.obs <- atan2(y.axis - 1/2, x.axis - 1/2)
    theta.obs[theta.obs < 0] = theta.obs[theta.obs < 0] + 2 * 
        pi
    obsLabel = (r.obs < gamma.fun(theta.obs))
    n.In = sum(obsLabel)
    n.Out = sum(!obsLabel)
    obs[obsLabel] = rnorm(n.In, mean = mu.in, sd = sd.in)
    obs[!obsLabel] = rnorm(n.Out, mean = mu.out, sd = sd.out)
    return(list(intensity = obs, theta.obs = theta.obs, r.obs = r.obs, 
        center = center, x = x.axis, y = y.axis))
}



# Example 1: R code only.  This uses the code from BayesBD.norm above
uni.slice = function (x0, g, w = 1, m = Inf, lower = -Inf, upper = +Inf, 
    gx0 = NULL) 
{
    if (is.null(gx0)) {
        gx0 <- g(x0)
    }
    logy <- gx0 - rexp(1)
    u <- runif(1, 0, w)
    L <- x0 - u
    R <- x0 + (w - u)
    if (is.infinite(m)) {
        repeat {
            if (L <= lower) 
                break
            if (g(L) <= logy) 
                break
            L <- L - w
        }
        repeat {
            if (R >= upper) 
                break
            if (g(R) <= logy) 
                break
            R <- R + w
        }
    }
    else if (m > 1) {
        J <- floor(runif(1, 0, m))
        K <- (m - 1) - J
        while (J > 0) {
            if (L <= lower) 
                break
            if (g(L) <= logy) 
                break
            L <- L - w
            J <- J - 1
        }
        while (K > 0) {
            if (R >= upper) 
                break
            if (g(R) <= logy) 
                break
            R <- R + w
            K <- K - 1
        }
    }
    if (L < lower) {
        L <- lower
    }
    if (R > upper) {
        R <- upper
    }
    count = 0
    repeat {
	  count = count+1
        x1 <- runif(1, L, R)
        gx1 <- g(x1)
        if (gx1 >= logy) 
            break
        if (x1 > x0) {
            R <- x1
        }
        else {
            L <- x1
        }
    }
    attr(x1, "count") = count
    attr(x1, "log.density") <- gx1
    return(x1)
}


set.seed(12345)
gamma.fun = ellipse(a = 0.35, b = 0.25)
obs = parnormobs(m = 100, mu.in = 4, mu.out = 1,sd.in = 1.5, sd.out = 1, design = 'J', gamma.fun)
rotate <- function(x) t(apply(x, 2, rev))  # rotate closewise by 90 degrees
image(rotate(obs$intensity), axes = FALSE, asp = 1, main = 'observation')
ini.mean = 0.4
n.run = 5000
n.burn = 1000
J = 10
time1 = rep(NA, 5000)
time2 = time1
t1 = proc.time()
    mu.fun <- function(theta) theta * 0 + ini.mean
    mu = c(mu.fun(obs$theta.obs))
    L = 2 * J + 1
    alpha.tau = 500
    beta.tau = 1
    alpha.lambda = 2
    beta.lambda = 1
    obs$demean = obs$r.obs - mu
    tmp.mat = sapply(1:L, function(k) eigen.fun(k)(c(obs$theta.obs)))
    an.smp = matrix(NA, L, n.run)
    par.smp = matrix(NA, 4, n.run)
    tau.smp = rep(NA, n.run)
    lambda.smp = rep(NA, n.run)
    an.ini = rep(0, L)
	n.all = length(obs$intensity)
    in.ini = (obs$r.obs < mu)
    m0 = mean(obs$intensity)	
    v0 = 1/var(as.vector(obs$intensity))
    m1.ini = sum(in.ini * obs$intensity)/sum(in.ini)
    m2.ini = sum((!in.ini) * obs$intensity)/sum(!in.ini)
    s1.ini = sd(as.vector(obs$intensity)[as.vector(in.ini)==TRUE])
    s2.ini = sd(as.vector(obs$intensity)[as.vector(in.ini)==FALSE])
    tau.ini = 500
    lambda.ini = 1
    cn.ini = sapply(0:J, function(ith) 2 * pi * exp(-2 * lambda.ini) * 
        besselI(2 * lambda.ini, ith))
    eigen.cn.ini = rep(cn.ini, each = 2)[-1]
    diff.ini = obs$demean - c(tmp.mat %*% an.ini)
    tmp = (diff.ini < 0)
    n.in <- sum(tmp)
    alpha1.ini = -log(s1.ini) 
    alpha2.ini = - log(s2.ini)
    beta.ini = -((2*((s1.ini)^2))^(-1))*sum(in.ini * ((obs$intensity-m1.ini)^2))-((2*((s2.ini)^2))^(-1))*sum((!in.ini) * ((obs$intensity-m2.ini)^2))
    mh.step <- function(k, an, alpha1,alpha2, beta, tmp.mat, eigen.cn, tau,n.in,m1, m2, s1, s2) {
	  ret = list(an = an,n.in = n.in, beta = beta)
        eigen.cn.ini = eigen.cn
        an.old = matrix(an,L,1)
	  an.new.k = rnorm(1,an.old[k],.05)
	  an.new = an.old
	  an.new[k,1] = an.new.k
	  lL.old = n.in * alpha1-n.in*alpha2 + beta - t(an.old)%*%diag(1/eigen.cn.ini)%*%an.old*tau.ini/2 
	  r.mat = c(tmp.mat %*% an.new + mu)
        tmp <- (obs$r.obs <= r.mat)
        n.in.new <- sum(tmp)
	  beta.ini = -((2*((s1)^2))^(-1))*sum(tmp * ((obs$intensity-m1)^2))-((2*((s2)^2))^(-1))*sum((!tmp) * ((obs$intensity-m2)^2))
	  lL.new = n.in.new * alpha1-n.in.new*alpha2 + beta.ini - t(an.new)%*%diag(1/eigen.cn.ini)%*%an.new*tau.ini/2
        r = lL.new - lL.old + dnorm(an.new.k, an.old[k,1],.05) - dnorm(an.old[k,1],an.new.k ,.05)
        R <- min(exp(r), 1)
        if(runif(1) <= R) {
       	ret = list(an = an.new,n.in = n.in.new, beta = beta.ini)
        } 
	  return(ret)
    }
    logL.anini <- function(k, tmpmat, an, mu, demean, intensityobs, mu1, mu2, sd1, sd2, tau, eigencn){
		ret = function(t){
			annew = an
			annew[k] = t
			rmat = tmpmat%*%annew+mu
			tmp = ifelse(as.vector(demean) < rmat, 1, 0)
			ninnew = sum(tmp)
			sdcomp = -sum(ifelse(tmp == 1, ((as.vector(intensityobs) - mu1)^2)/(2*sd1^2), ((as.vector(intensityobs) - mu2)^2)/(2*sd2^2)))
			ret2 = ninnew * (-log(sd1))-ninnew*(-log(sd2)) + sdcomp - t(annew)%*%diag(1.0/eigencn)%*%annew*tau/2
			attr(ret2, "nin") = ninnew
			attr(ret2, "sdcomp") = sdcomp
			return(ret2)
		}
		return(ret)	 
    }
    logL.lambda = function(tau, an) {
        ret = function(lambda) {
            cn = sapply(0:J, function(ith) 2 * pi * exp(-2 * 
                lambda) * besselI(2 * lambda, ith))
            eigen.cn = rep(cn, each = 2)[-1]
            ret2 = -1/2 * (sum(log(eigen.cn)) + tau * sum(an^2/eigen.cn)) + 
                (alpha.lambda - 1) * log(lambda) - beta.lambda * 
                lambda
            return(ret2)
        }
        return(ret)
    }
	count1 = 0
	count2 = 0
    for (ith in 1:n.run) {
	t = proc.time()
        for (k in 1:L) {
			# use next four lines for slice sampling
          		#an.n.new = uni.slice(an.ini[k], m=50, g = logL.anini(k, tmp.mat, an.ini, mu, obs$r.obs, obs$intensity, m1.ini, m2.ini, s1.ini, s2.ini, tau.ini, eigen.cn.ini), lower = -100, upper = 100)
			#n.in = attr(an.n.new, "ninnew")
			#an.ini[k] = an.n.new
			#beta.ini = attr(an.n.new, "sdcomp")
			#count1 = max(count1, attr(an.n.new, "count"))
			# alternatively to the above four lines, use next four lines for MH sampling
			an.n.new = mh.step(k,an.ini, alpha1.ini,alpha2.ini, beta.ini,tmp.mat, eigen.cn.ini, tau.ini,n.in, m1.ini, m2.ini, s1.ini, s2.ini)
			n.in = an.n.new$n.in
			an.ini = an.n.new$an
			beta.ini = an.n.new$beta
	        }
		time1[ith] = (proc.time()-t)[3]
	  a.star = lambda.ini + L/2
        b.star = beta.tau + sum(an.ini^2/eigen.cn.ini)/2
        tau.ini = rgamma(1, shape = a.star, rate = b.star)
        r.mat = c(tmp.mat %*% an.ini + mu)
        tmp <- (obs$r.obs <= r.mat)
        n.in <- sum(tmp)
        n.out = length(r.mat) - n.in
	  mean.in = ifelse(sum(tmp)==0,0,sum(tmp*obs$intensity)/n.in)
	  mean.out = ifelse(sum(!tmp)==0,0,sum((!tmp)*obs$intensity)/n.out)
        m1.0 = (n.in/(n.in+1))*mean.in + (1/(n.in+1))*m0
	  m2.0 = (n.out/(n.out+1))*mean.out + (1/(n.out+1))*m0
	  alph1.0 = 10+n.in/2
	  beta1.0 = .1+.5*sum(tmp*((obs$intensity-mean.in)^2)) + (n.in/(1+n.in))*(.5*(mean.in - m0)^2)
        alph2.0 = 10+n.out/2
	  beta2.0 = .11+.5*sum((!tmp)*((obs$intensity-mean.out)^2)) + (n.out/(1+n.out))*(.5*(mean.out - m0)^2)
	  x3 = 1/rgamma(1,shape = alph1.0,rate = beta1.0)
	  x4 = 1/rgamma(1,shape = alph2.0,rate = beta2.0)	  
	  s1.ini = x3^.5
	  s2.ini = x4^.5
	  x1 = rnorm(1,m1.0,sd = s1.ini/sqrt(n.in+1))
        x2 = rnorm(1,m2.0,sd = s2.ini/sqrt(n.out+1))
        m1.ini = x1
	  m2.ini = x2
        alpha1.ini = -log(s1.ini) 
	  alpha2.ini = - log(s2.ini)
        beta.ini = -((2*((s1.ini)^2))^(-1))*sum(tmp * ((obs$intensity-m1.ini)^2))-((2*((s2.ini)^2))^(-1))*sum((!tmp) * ((obs$intensity-m2.ini)^2))
        t = proc.time()
	  lambda.ini = uni.slice(lambda.ini, g = logL.lambda(tau = tau.ini, 
            an = an.ini), lower = 0, upper = 100)
		count2 = max(count2, attr(lambda.ini, "count"))
	  time2[ith] = (proc.time()-t)[3]
	  cn.ini = sapply(0:J, function(ith) 2 * pi * exp(-2 * lambda.ini) * 
        besselI(2 * lambda.ini, ith))
        eigen.cn.ini = rep(cn.ini, each = 2)[-1]
	  gxZ = n.in * alpha1.ini-n.in*alpha2.ini + beta.ini - t(an.ini)%*%diag(1.0/eigen.cn.ini)%*%an.ini*tau.ini/2
        an.smp[, ith] = an.ini
        par.smp[, ith] = c(m1.ini,m2.ini,s1.ini,s2.ini)
        lambda.smp[ith] = lambda.ini
        tau.smp[ith] = tau.ini
          }
       an.MC = apply(an.smp[, n.burn:n.run], 1, mean)
    gamma.MC <- function(theta.arg) {
        c(sapply(1:L, function(k) eigen.fun(k)(theta.arg)) %*% 
            an.MC + mu.fun(theta.arg))
    }
t2 = proc.time()
t2-t1
count1
count2
theta.plot = seq(from = 0, to = 2*pi, length.out = 200)
plot.val = gamma.MC(theta.plot)
x.plot = plot.val*cos(theta.plot)+.5
y.plot = plot.val*sin(theta.plot)+.5
lines(x.plot, y.plot, lwd=2, col = "blue")
sum(time1)
sum(time2)



# Example 2: c++ functions mhstep and unisliceL used for MCMC updating are called # within an R loop
set.seed(12345)
gamma.fun = ellipse(a = 0.35, b = 0.25)
obs = parnormobs(m = 100, mu.in = 4, mu.out = 1,sd.in = 1.5, sd.out = 1, design = 'J', gamma.fun)
rotate <- function(x) t(apply(x, 2, rev))  # rotate clockwise by 90 degrees
image(rotate(obs$intensity), axes = FALSE, asp = 1, main = 'observation')
time1 = rep(0,5000)
time2 = rep(0,5000)
ini.mean = 0.4
n.run = 5000
n.burn = 1000
J = 10
tt1 =proc.time()
    mu.fun <- function(theta) theta * 0 + ini.mean
    mu = c(mu.fun(obs$theta.obs))
    L = 2 * J + 1
    alpha.tau = 500
    beta.tau = 1
    alpha.lambda = 2
    beta.lambda = 1
    obs$demean = obs$r.obs - mu
    tmp.mat = sapply(1:L, function(k) eigen.fun(k)(c(obs$theta.obs)))
    an.smp = matrix(NA, L, n.run)
    par.smp = matrix(NA, 4, n.run)
    tau.smp = rep(NA, n.run)
    lambda.smp = rep(NA, n.run)
    an.ini = rep(0, L)
    n.all = length(obs$intensity)
    in.ini = (obs$r.obs < mu)
    m0 = mean(obs$intensity)	
    v0 = 1/var(as.vector(obs$intensity))
    m1.ini = sum(in.ini * obs$intensity)/sum(in.ini)
    m2.ini = sum((!in.ini) * obs$intensity)/sum(!in.ini)
    s1.ini = sd(as.vector(obs$intensity)[as.vector(in.ini)==TRUE])
    s2.ini = sd(as.vector(obs$intensity)[as.vector(in.ini)==FALSE])
    tau.ini = 500
    lambda.ini = 1
    cn.ini = sapply(0:J, function(ith) 2 * pi * exp(-2 * lambda.ini) * 
        besselI(2 * lambda.ini, ith))
    eigen.cn.ini = rep(cn.ini, each = 2)[-1]
    diff.ini = obs$demean - c(tmp.mat %*% an.ini)
    tmp = (diff.ini < 0)
    n.in <- sum(tmp)
    alpha1.ini = -log(s1.ini) 
    alpha2.ini = - log(s2.ini)
	count1 = rep(NA,5000*L)
	count2 = rep(NA,5000)
    beta.ini = -((2*((s1.ini)^2))^(-1))*sum(in.ini * ((obs$intensity-m1.ini)^2))-((2*((s2.ini)^2))^(-1))*sum((!in.ini) * ((obs$intensity-m2.ini)^2))
    gxZ = n.in * alpha1.ini-n.in*alpha2.ini + beta.ini - t(an.ini)%*%diag(1.0/eigen.cn.ini)%*%an.ini*tau.ini/2
    for (ith in 1:n.run) {
	  t1t = proc.time()
        for (k in 1:L) {
			# use next four lines for slice sampling via c++
			an.n.new = unisliceZ(k-1, gxZ, tmp.mat, mu, obs$intensity, obs$r.obs, an.ini, alpha1.ini,alpha2.ini, eigen.cn.ini, tau.ini, n.in, m1.ini, m2.ini, s1.ini, s2.ini)
			n.in = an.n.new$nin
			an.ini[k] = an.n.new$x1
			gxZ = an.n.new$gxZ
			count1[L*ith-L+k] = an.n.new$count
			#alternatively, use next four lines for MH sampling via c++
			#an.n.new = mhstep(k-1, gxZ, tmp.mat, mu, obs$intensity, obs$r.obs, an.ini, alpha1.ini, alpha2.ini, eigen.cn.ini, tau.ini, n.in, m1.ini, m2.ini, s1.ini, s2.ini)
			#n.in = an.n.new$nin
			#an.ini[k] = an.n.new$x1
			#gxZ = an.n.new$gxZ
		   }
	  time1[ith] = (proc.time() - t1t)[3]
	  a.star = lambda.ini + L/2
        b.star = beta.tau + sum(an.ini^2/eigen.cn.ini)/2
        tau.ini = rgamma(1, shape = a.star, rate = b.star)
        r.mat = c(tmp.mat %*% an.ini + mu)
        tmp <- (obs$r.obs <= r.mat)
        n.in <- sum(tmp)
        n.out = length(r.mat) - n.in
	  mean.in = ifelse(sum(tmp)==0,0,sum(tmp*obs$intensity)/n.in)
	  mean.out = ifelse(sum(!tmp)==0,0,sum((!tmp)*obs$intensity)/n.out)
        m1.0 = (n.in/(n.in+1))*mean.in + (1/(n.in+1))*m0
	  m2.0 = (n.out/(n.out+1))*mean.out + (1/(n.out+1))*m0
	  alph1.0 = .01+n.in/2
	  beta1.0 = .01+.5*sum(tmp*((obs$intensity-mean.in)^2)) + (n.in/(1+n.in))*(.5*(mean.in - m0)^2)
        alph2.0 = .01+n.out/2
	  beta2.0 = .01+.5*sum((!tmp)*((obs$intensity-mean.out)^2)) + (n.out/(1+n.out))*(.5*(mean.out - m0)^2)
	  x3 = 1/rgamma(1,shape = alph1.0,rate = beta1.0)
	  x4 = 1/rgamma(1,shape = alph2.0,rate = beta2.0)	  
	  s1.ini = x3^.5
	  s2.ini = x4^.5
	  x1 = rnorm(1,m1.0,sd = s1.ini/sqrt(n.in+1))
        x2 = rnorm(1,m2.0,sd = s2.ini/sqrt(n.out+1))
        m1.ini = x1
	  m2.ini = x2
        alpha1.ini = -log(s1.ini) 
	  alpha2.ini = - log(s2.ini)
        beta.ini = -((2*((s1.ini)^2))^(-1))*sum(tmp * ((obs$intensity-m1.ini)^2))-((2*((s2.ini)^2))^(-1))*sum((!tmp) * ((obs$intensity-m2.ini)^2))
 	  gx0 = -1/2 * (sum(log(eigen.cn.ini)) + tau.ini * sum((an.ini^2)/eigen.cn.ini)) + (alpha.lambda - 1) * log(lambda.ini) - beta.lambda * lambda.ini
	  t1 = proc.time()
	  lambda.ini = unisliceL(lambda.ini, gx0, J, tau.ini, an.ini,  alpha.lambda,  beta.lambda, lambda.ini)
	  count2[ith] = lambda.ini$count
	  lambda.ini = lambda.ini$x1
	  #lambda.ini = uni.slice(lambda.ini, g = logL.lambda(tau = tau.ini, 
        #    an = an.ini), lower = 0, upper = 100)
	  t2 = proc.time()
	  time2[ith] = (t2-t1)[3]
        cn.ini = sapply(0:J, function(ith) 2 * pi * exp(-2 * lambda.ini) * 
        besselI(2 * lambda.ini, ith))
        eigen.cn.ini = rep(cn.ini, each = 2)[-1]
	  gxZ = n.in * alpha1.ini-n.in*alpha2.ini + beta.ini - t(an.ini)%*%diag(1.0/eigen.cn.ini)%*%an.ini*tau.ini/2
	  an.smp[, ith] = an.ini
        par.smp[, ith] = c(m1.ini,m2.ini,s1.ini,s2.ini)
        lambda.smp[ith] = lambda.ini
        tau.smp[ith] = tau.ini
    }
    an.MC = apply(an.smp[, n.burn:n.run], 1, mean)
    gamma.MC <- function(theta.arg) {
        c(sapply(1:L, function(k) eigen.fun(k)(theta.arg)) %*% 
            an.MC + mu.fun(theta.arg))
    }
tt2 = proc.time()
tt2-tt1
theta.plot = seq(from = 0, to = 2*pi, length.out = 200)
plot.val = gamma.MC(theta.plot)
x.plot = plot.val*cos(theta.plot)+.5
y.plot = plot.val*sin(theta.plot)+.5
lines(x.plot, y.plot, lwd=2)
sum(time1)
sum(time2)
hist(count1)
hist(count2)



# Example 3: c++ only.  BayesBDnormal is used to run the entire sampling process within c++.
set.seed(12345)
gamma.fun = ellipse(a = 0.35, b = 0.25)
obs = parnormobs(m = 100, mu.in = 4, mu.out = 1,sd.in = 1.5, sd.out = 1, design = 'J', gamma.fun)
rotate <- function(x) t(apply(x, 2, rev))  # rotate closewise by 90 degrees
image(rotate(obs$intensity), axes = FALSE, asp = 1, main = 'observation')
# optionally, source functions from text file first...
#sourceCpp("E:\\Research\\BayesBDCoding\\eigenfun.cpp")
#sourceCpp("E:\\Research\\BayesBDCoding\\mhstep.cpp")
#sourceCpp("E:\\Research\\BayesBDCoding\\unisliceL.cpp")
#sourceCpp("E:\\Research\\BayesBDCoding\\BayesBDnormal.cpp")
t1 = proc.time()
cppsamp = BayesBDnormal(obs, .4, 4000, 1000, 10)
t2 = proc.time()
t2-t1
x = cppsamp$esttheta*cos(cppsamp$thetaplot)+.5
y = cppsamp$esttheta*sin(cppsamp$thetaplot)+.5
lines(x,y, lty = 2, lwd = 3)



# Runtime results: on an Intel Core i7-4790K CPU @ 4.00 GHz with 16 GB RAM running RGui 64-bit on Windows 10
# 100 x 100 obs
# SLICE sampling
#                       user      system    elapsed
#   c++ only            343.01    36.73     380.39   
#   c++ within R loop   281.47    0.94      283.26         
#   Only R              2497.30   0.93      2501.98  

# Runtime results: on an Intel Core i7-4790K CPU @ 4.00 GHz with 16 GB RAM running RGui 64-bit on Windows 10
# 100 x 100 obs
# MH sampling
#                       user      system    elapsed
#   c++ only            107.30    37.61     166.06    
#   c++ within R loop   27.13     0.46      27.74      
#   Only R              53.07     0.48      53.57   
       

# laptop mh
#R     167.09    1.14  169.11 
#Rc++  86.85     0.70   88.03 
#c++   67.25    0.04   67.93  
